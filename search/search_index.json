{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"rezup A cross-platform Rez production tooling manager Read The Docs Why use rezup Easier to setup/update Rez venv Easier to install custom Rez extensions (plugins) Easier to provide different Rez venv setup for different purpose Install This installs the rezup full package, command line tool and the api package. $ pip install rezup To upgrade , you only need to upgrade the api package. So to avoid re-creating console-script. $ pip install -U rezup-api Quick start Simply calling rezup in terminal will suffice. $ rezup The command above is a shorthand for rezup use .main , which means to enter a Rez venv container named .main . Usually you must rezup add a new container before you can use it. But default container .main will automatically be created if it's not existing yet, for the first time. So, what will & should happen after calling rezup ? A most basic recipe will be written into user home directory ( ~/rezup.toml ) Default container .main will be created with that recipe Wait for it... Bam! A vanilla Rez environment is presented (In subprocess) Try rez --version or any rez command Once you're done, simply type exit to escape. As you may have seen, Rez venv is in the container and is deployed with a recipe file. Please visit Container-Recipe page for more detail about how you can auth and create a richer container by the recipe. And for other rezup commands, please run rezup --help or rezup [COMMAND] --help for each command's usage. $ rezup --help Or, visit Command page.","title":"Overview"},{"location":"#rezup","text":"A cross-platform Rez production tooling manager Read The Docs","title":"rezup"},{"location":"#why-use-rezup","text":"Easier to setup/update Rez venv Easier to install custom Rez extensions (plugins) Easier to provide different Rez venv setup for different purpose","title":"Why use rezup"},{"location":"#install","text":"This installs the rezup full package, command line tool and the api package. $ pip install rezup To upgrade , you only need to upgrade the api package. So to avoid re-creating console-script. $ pip install -U rezup-api","title":"Install"},{"location":"#quick-start","text":"Simply calling rezup in terminal will suffice. $ rezup The command above is a shorthand for rezup use .main , which means to enter a Rez venv container named .main . Usually you must rezup add a new container before you can use it. But default container .main will automatically be created if it's not existing yet, for the first time. So, what will & should happen after calling rezup ? A most basic recipe will be written into user home directory ( ~/rezup.toml ) Default container .main will be created with that recipe Wait for it... Bam! A vanilla Rez environment is presented (In subprocess) Try rez --version or any rez command Once you're done, simply type exit to escape. As you may have seen, Rez venv is in the container and is deployed with a recipe file. Please visit Container-Recipe page for more detail about how you can auth and create a richer container by the recipe. And for other rezup commands, please run rezup --help or rezup [COMMAND] --help for each command's usage. $ rezup --help Or, visit Command page.","title":"Quick start"},{"location":"command/","text":"Command Line Interface Commands debug logging You can always add --debug or -D flag into any command to display debug message. $ rezup use Quick start, auto use default container '.main' The command use can be omitted $ rezup Use container 'foo' $ rezup use foo Ignore remote and only use local container If local and remote root are both set for the container, remote will be sourced first by default even local container has newer revision. So sometimes you may want to ignore the remote. $ rezup use foo --local Use 'foo' and run command Everything after -- will be passed as command. $ rezup use foo -- rez-env $ rezup add Create & use new revision for local container '.main' $ rezup add Create & use new revision for local container 'foo' $ rezup add foo Create new revision for remote container '.main' and exit $ rezup add --remote --skip-use $ rezup drop Not ready for prime-time This command actually is not fully functional yet. $ rezup status List containers and info $ rezup status Show detailed info of specific container $ rezup status foo Shell Prompt You may customize the prompt with environ var REZUP_PROMPT . To get the container name for custom prompt, use env var REZUP_CONTAINER . You may also want to use REZUP_USING_REMOTE to indicate whether current rez venv session is sourced from local or remote container. Set Prompts in Unix Shell Due to the rcfiles, I cannot change prompt from Rezup launch script. So unless copying all rcfiles into a temp dir and modify prompt from there (just like how Rez changing prompt in sub-shell), you have to do this in your own ~/.bashrc or ~/.cshrc . bash, zsh # ~/.bashrc if [ -n \" ${ REZUP_PROMPT - } \" ] ; then export PS1 = $REZUP_PROMPT$PS1 fi csh, tcsh # ~/.cshrc if ( ! $? prompt ) then set prompt = \"% \" endif if ( $? REZUP_PROMPT ) then set prompt = \" ${ REZUP_PROMPT }${ prompt } \" endif Shell detection Rezup uses an excellent tool shellingham to detect current shell for spawning sub-shell. This works great on Windows, however on POSIX, shellingham seems detecting shell with env $SHELL in most cases, which means mostly what you get is the login shell, not the current shell that is being used. For example: $ python3 -c \"import shellingham;print(shellingham.detect_shell())\" $ ( 'bash' , '/bin/bash' ) $ csh % python3 -c \"import shellingham;print(shellingham.detect_shell())\" % ( 'bash' , '/bin/bash' ) Why $SHELL doesn't change when I run new shell? To overcome this, use env REZUP_DEFAULT_SHELL to set the shell you want. Notes Remember to convert line ending to Unix format if shell scripts have been edited on Windows. Or may get error like ^M: Command not found . May get error like Unmatched \" in csh shell when the prompt contains linebreak.","title":"Command"},{"location":"command/#command-line-interface","text":"","title":"Command Line Interface"},{"location":"command/#commands","text":"debug logging You can always add --debug or -D flag into any command to display debug message.","title":"Commands"},{"location":"command/#rezup-use","text":"Quick start, auto use default container '.main' The command use can be omitted $ rezup Use container 'foo' $ rezup use foo Ignore remote and only use local container If local and remote root are both set for the container, remote will be sourced first by default even local container has newer revision. So sometimes you may want to ignore the remote. $ rezup use foo --local Use 'foo' and run command Everything after -- will be passed as command. $ rezup use foo -- rez-env","title":"$ rezup use"},{"location":"command/#rezup-add","text":"Create & use new revision for local container '.main' $ rezup add Create & use new revision for local container 'foo' $ rezup add foo Create new revision for remote container '.main' and exit $ rezup add --remote --skip-use","title":"$ rezup add"},{"location":"command/#rezup-drop","text":"Not ready for prime-time This command actually is not fully functional yet.","title":"$ rezup drop"},{"location":"command/#rezup-status","text":"List containers and info $ rezup status Show detailed info of specific container $ rezup status foo","title":"$ rezup status"},{"location":"command/#shell-prompt","text":"You may customize the prompt with environ var REZUP_PROMPT . To get the container name for custom prompt, use env var REZUP_CONTAINER . You may also want to use REZUP_USING_REMOTE to indicate whether current rez venv session is sourced from local or remote container.","title":"Shell Prompt"},{"location":"command/#set-prompts-in-unix-shell","text":"Due to the rcfiles, I cannot change prompt from Rezup launch script. So unless copying all rcfiles into a temp dir and modify prompt from there (just like how Rez changing prompt in sub-shell), you have to do this in your own ~/.bashrc or ~/.cshrc .","title":"Set Prompts in Unix Shell"},{"location":"command/#bash-zsh","text":"# ~/.bashrc if [ -n \" ${ REZUP_PROMPT - } \" ] ; then export PS1 = $REZUP_PROMPT$PS1 fi","title":"bash, zsh"},{"location":"command/#csh-tcsh","text":"# ~/.cshrc if ( ! $? prompt ) then set prompt = \"% \" endif if ( $? REZUP_PROMPT ) then set prompt = \" ${ REZUP_PROMPT }${ prompt } \" endif","title":"csh, tcsh"},{"location":"command/#shell-detection","text":"Rezup uses an excellent tool shellingham to detect current shell for spawning sub-shell. This works great on Windows, however on POSIX, shellingham seems detecting shell with env $SHELL in most cases, which means mostly what you get is the login shell, not the current shell that is being used. For example: $ python3 -c \"import shellingham;print(shellingham.detect_shell())\" $ ( 'bash' , '/bin/bash' ) $ csh % python3 -c \"import shellingham;print(shellingham.detect_shell())\" % ( 'bash' , '/bin/bash' ) Why $SHELL doesn't change when I run new shell? To overcome this, use env REZUP_DEFAULT_SHELL to set the shell you want.","title":"Shell detection"},{"location":"command/#notes","text":"Remember to convert line ending to Unix format if shell scripts have been edited on Windows. Or may get error like ^M: Command not found . May get error like Unmatched \" in csh shell when the prompt contains linebreak.","title":"Notes"},{"location":"container/","text":"Structure A container provides Rez environment from it's revision . Each container holds at least one virtual environment folder that named by timestamp, which is a revision . With that convention, the latest version of environment can be sorted out and used without affecting existing container user. ~\\.rezup # container root | + - {container} | : : : : + - {revision} # venv and bin tools lives here : | + - {revision} # folder named as timestamp, e.g. 1619780350.58 | + - {revision} # take latest when calling `rezup use {container}` Remote Container To manage Rez venv in production, we may want every machine to have the same Rez venv setup and try keeping them up-to-date. For this purpose, a centralized remote container is needed as a guidance for rezup use command to pick the right Rez venv setup from there, and create it locally if needed. How that works ? When calling rezup use {container} , if the container has remote set, rezup will find the latest valid revision from remote and see if the same revision exists in local and use it. If not, create a new one by the recipe in that remote revision before use. But what if local container contains revisions that doesn't exists in remote ? The command rezup use always respect remote revision even there's more latest revision exists in local. Unless rezup use --local is used and remote will be ignored. The Difference Both local and remote container have the same structure, the difference is the payload. Local Where the Rez venv actually exists. Can be created by command rezup add {container} Remote Only contains the venv installation manifest file (recipe) rezup.toml that uploaded by command rezup add {container} --remote Local doesn't have to be in local Local container root can be pointed into network drive, but if that's how it setup, keeps an eye on which Python interpreter is being used or the venv may not be usable. Recipe A recipe file defines how a Rez venv should be built. File Naming Recipe files usually be saved to and loaded from user home directory, and should be named with container (if not default container) so that command rezup add <container> could pick it up when creating corresponding container, for example: ~/rezup.toml for container .main , the default ~/rezup.dev.toml for container dev ~/rezup.test.toml for container test ~/rezup.{name}.toml for container {name} File Content A recipe file may look like the following example, see below for details about each section. description = \"My rez setup\" [root] local = \"\" remote = \"\" [dotenv] [env] REZ_CONFIG_FILE = \"/path/to/rezconfig.py\" MY_CUSTOMS_ENV = \"my value\" [pip] options = [ \"--disable-pip-version-check\" , ] [pip.env] [rez] name = \"rez\" url = \"rez>=2.83\" # a PyPi version specifier or repository path lib = [ \"pythonfinder\" , \"pyside2\" , \"Qt5.py\" , ] [[extension]] name = \"foo\" url = \"~/dev/foo\" edit = true # install this in edit mode (pip --edit) [[extension]] name = \"bar\" url = \"git+git://github.com/get-bar/bar\" isolation = true # additional venv will be created just for this package python = 2.7 # the python version for the venv of this package lib = [ \"pathlib2\" ] [ shared ] # about to be deprecated, name = \"prod\" # use 'rez.lib' or 'extension.lib' section instead requires = [ \"six\" ] description description = \"hello, Rez!\" Like a comment, for knowing what this recipe is for. root Define where the root of this container should be. [root] local = \"\" remote = \"/studio/remote/.rezup\" local If the value is false or empty string \"\" , env var REZUP_ROOT_LOCAL will be used, or the default ~/.rezup . remote If the value is false or empty string \"\" , env var REZUP_ROOT_REMOTE will be used, or no remote for this container. dotenv The .env files will be loaded in order when container revision is being used, if provided. [dotenv] 1 = \"/to/my.env\" # non platform specific, load firstly, sort by key 2 = \"/to/other.env\" [dotenv.linux] a = \"/to/lnx.env\" # platform specific, load secondly, sort by key [dotenv.darwin] a = \"/to/mac.env\" # platform specific, load secondly, sort by key [dotenv.windows] a = \"/to/win.env\" # platform specific, load secondly, sort by key The key can be anything, they are only for sorting. env These will be loaded when container revision is being used, if provided. [env] REZ_CONFIG_FILE = \"/path/to/rezconfig.py\" pip Additional pip command options and environment variables to use when pip install -ing packages. [pip] options = [ \"-qq\" , \"--retries=2\" , \"--timeout=5\" , \"--no-input\" , \"--disable-pip-version-check\" , \"--proxy=https://user_name:password@proxyname:port\" , ] [pip.env] HTTP_PROXY = \"http://proxyname:port\" HTTPS_PROXY = \"http://proxyname:port\" rez Rez venv setup configurations [rez] # required name = \"rez\" url = \"/path/to/source/rez\" # optional edit = true flags = [ \"-E\" ] python = 3.7 lib = [ \"pythonfinder\" , \"pyside2\" , \"Qt5.py\" , ] Name Required Description name O The name of the package url O The url that pass to pip install . Could be version specifier like rez>=2.90 , or from version control like git+https://github.com/nerdvegas/rez , or local source path. edit - Just like pip install -e , install package in edit mode or not. python - The Python to create venv with. Use current if not set. Could be path to Python executable, or version flags - Python interpreter flags, default [\"-E\"] if not set. No flag will be added if the value is an empty list. lib - Additional Python packages to be pip installed with. extension [[ extension ]] # note this is a list but it's name is not plural # required name = \"foo\" url = \"foo>=0.5\" # optional edit = false flags = [ \"-E\" ] isolation = true python = 2.7 # ignored if `isolation` is false lib = [ \"pathlib2\" ] Just like the section rez , but there's an extra option isolation can be used. Shouldn't be needed in most cases though. If isolation is true, a venv will be created just for this extension with Rez installed as lib into it. If false as default, the extension will be installed into the Rez venv. shared [ shared ] # about to be deprecated, name = \"prod\" # use 'rez.lib' or 'extension.lib' section instead requires = [ \"six\" ] To be deprecated See davidlatwe/rezup#62 . Original description or faster deploy, dependency packages can be installed in here, and will be shared across all revisions in one container (all revisions that use same name of shared lib). This works by creating a .pth file that contains the absolute path of shared lib in Rez venv and only that venv. So this will not be shared with the extension that has isolation set to true. Production Install Rezup installs Rez and the tooling by following Rez installation script's \"production-install\" schema : Install Rez in a fresh Python virtual environment. Command line entry-points (bin tools) are all patched with Python interpreter flag -E . All bin tools get stored in a sub-directory of regular Python bin tools install location ( {venv}/bin/rez or {venv}/Scripts/rez on Windows). See Rez Wiki Why Not Pip For Production? section for a bit more detail. But if Rez gets installed in edit-mode , it will fail to compute the location of those production-installed bin tools and not able to provide features like nesting resolved contexts or running some specific rez tests. Rezup covers this situation by using custom entry-point script. If Rez is going to be installed in edit-mode, all bin tools will be generated with the custom script, which will pre-cache the location of bin tools when the session starts if, the environment variable REZUP_EDIT_IN_PRODUCTION exists and is not empty (see davidlatwe/rezup#56 for implementation detail). You may put that env var in e.g. rezup.dev.toml like this: [env] REZUP_EDIT_IN_PRODUCTION = \"1\" [rez] name = \"rez\" url = \"/path/to/source/rez\" edit = true","title":"Container"},{"location":"container/#structure","text":"A container provides Rez environment from it's revision . Each container holds at least one virtual environment folder that named by timestamp, which is a revision . With that convention, the latest version of environment can be sorted out and used without affecting existing container user. ~\\.rezup # container root | + - {container} | : : : : + - {revision} # venv and bin tools lives here : | + - {revision} # folder named as timestamp, e.g. 1619780350.58 | + - {revision} # take latest when calling `rezup use {container}`","title":"Structure"},{"location":"container/#remote-container","text":"To manage Rez venv in production, we may want every machine to have the same Rez venv setup and try keeping them up-to-date. For this purpose, a centralized remote container is needed as a guidance for rezup use command to pick the right Rez venv setup from there, and create it locally if needed. How that works ? When calling rezup use {container} , if the container has remote set, rezup will find the latest valid revision from remote and see if the same revision exists in local and use it. If not, create a new one by the recipe in that remote revision before use. But what if local container contains revisions that doesn't exists in remote ? The command rezup use always respect remote revision even there's more latest revision exists in local. Unless rezup use --local is used and remote will be ignored. The Difference Both local and remote container have the same structure, the difference is the payload. Local Where the Rez venv actually exists. Can be created by command rezup add {container} Remote Only contains the venv installation manifest file (recipe) rezup.toml that uploaded by command rezup add {container} --remote Local doesn't have to be in local Local container root can be pointed into network drive, but if that's how it setup, keeps an eye on which Python interpreter is being used or the venv may not be usable.","title":"Remote Container"},{"location":"container/#recipe","text":"A recipe file defines how a Rez venv should be built.","title":"Recipe"},{"location":"container/#file-naming","text":"Recipe files usually be saved to and loaded from user home directory, and should be named with container (if not default container) so that command rezup add <container> could pick it up when creating corresponding container, for example: ~/rezup.toml for container .main , the default ~/rezup.dev.toml for container dev ~/rezup.test.toml for container test ~/rezup.{name}.toml for container {name}","title":"File Naming"},{"location":"container/#file-content","text":"A recipe file may look like the following example, see below for details about each section. description = \"My rez setup\" [root] local = \"\" remote = \"\" [dotenv] [env] REZ_CONFIG_FILE = \"/path/to/rezconfig.py\" MY_CUSTOMS_ENV = \"my value\" [pip] options = [ \"--disable-pip-version-check\" , ] [pip.env] [rez] name = \"rez\" url = \"rez>=2.83\" # a PyPi version specifier or repository path lib = [ \"pythonfinder\" , \"pyside2\" , \"Qt5.py\" , ] [[extension]] name = \"foo\" url = \"~/dev/foo\" edit = true # install this in edit mode (pip --edit) [[extension]] name = \"bar\" url = \"git+git://github.com/get-bar/bar\" isolation = true # additional venv will be created just for this package python = 2.7 # the python version for the venv of this package lib = [ \"pathlib2\" ] [ shared ] # about to be deprecated, name = \"prod\" # use 'rez.lib' or 'extension.lib' section instead requires = [ \"six\" ]","title":"File Content"},{"location":"container/#description","text":"description = \"hello, Rez!\" Like a comment, for knowing what this recipe is for.","title":"description"},{"location":"container/#root","text":"Define where the root of this container should be. [root] local = \"\" remote = \"/studio/remote/.rezup\" local If the value is false or empty string \"\" , env var REZUP_ROOT_LOCAL will be used, or the default ~/.rezup . remote If the value is false or empty string \"\" , env var REZUP_ROOT_REMOTE will be used, or no remote for this container.","title":"root"},{"location":"container/#dotenv","text":"The .env files will be loaded in order when container revision is being used, if provided. [dotenv] 1 = \"/to/my.env\" # non platform specific, load firstly, sort by key 2 = \"/to/other.env\" [dotenv.linux] a = \"/to/lnx.env\" # platform specific, load secondly, sort by key [dotenv.darwin] a = \"/to/mac.env\" # platform specific, load secondly, sort by key [dotenv.windows] a = \"/to/win.env\" # platform specific, load secondly, sort by key The key can be anything, they are only for sorting.","title":"dotenv"},{"location":"container/#env","text":"These will be loaded when container revision is being used, if provided. [env] REZ_CONFIG_FILE = \"/path/to/rezconfig.py\"","title":"env"},{"location":"container/#pip","text":"Additional pip command options and environment variables to use when pip install -ing packages. [pip] options = [ \"-qq\" , \"--retries=2\" , \"--timeout=5\" , \"--no-input\" , \"--disable-pip-version-check\" , \"--proxy=https://user_name:password@proxyname:port\" , ] [pip.env] HTTP_PROXY = \"http://proxyname:port\" HTTPS_PROXY = \"http://proxyname:port\"","title":"pip"},{"location":"container/#rez","text":"Rez venv setup configurations [rez] # required name = \"rez\" url = \"/path/to/source/rez\" # optional edit = true flags = [ \"-E\" ] python = 3.7 lib = [ \"pythonfinder\" , \"pyside2\" , \"Qt5.py\" , ] Name Required Description name O The name of the package url O The url that pass to pip install . Could be version specifier like rez>=2.90 , or from version control like git+https://github.com/nerdvegas/rez , or local source path. edit - Just like pip install -e , install package in edit mode or not. python - The Python to create venv with. Use current if not set. Could be path to Python executable, or version flags - Python interpreter flags, default [\"-E\"] if not set. No flag will be added if the value is an empty list. lib - Additional Python packages to be pip installed with.","title":"rez"},{"location":"container/#extension","text":"[[ extension ]] # note this is a list but it's name is not plural # required name = \"foo\" url = \"foo>=0.5\" # optional edit = false flags = [ \"-E\" ] isolation = true python = 2.7 # ignored if `isolation` is false lib = [ \"pathlib2\" ] Just like the section rez , but there's an extra option isolation can be used. Shouldn't be needed in most cases though. If isolation is true, a venv will be created just for this extension with Rez installed as lib into it. If false as default, the extension will be installed into the Rez venv.","title":"extension"},{"location":"container/#shared","text":"[ shared ] # about to be deprecated, name = \"prod\" # use 'rez.lib' or 'extension.lib' section instead requires = [ \"six\" ] To be deprecated See davidlatwe/rezup#62 . Original description or faster deploy, dependency packages can be installed in here, and will be shared across all revisions in one container (all revisions that use same name of shared lib). This works by creating a .pth file that contains the absolute path of shared lib in Rez venv and only that venv. So this will not be shared with the extension that has isolation set to true.","title":"shared"},{"location":"container/#production-install","text":"Rezup installs Rez and the tooling by following Rez installation script's \"production-install\" schema : Install Rez in a fresh Python virtual environment. Command line entry-points (bin tools) are all patched with Python interpreter flag -E . All bin tools get stored in a sub-directory of regular Python bin tools install location ( {venv}/bin/rez or {venv}/Scripts/rez on Windows). See Rez Wiki Why Not Pip For Production? section for a bit more detail. But if Rez gets installed in edit-mode , it will fail to compute the location of those production-installed bin tools and not able to provide features like nesting resolved contexts or running some specific rez tests. Rezup covers this situation by using custom entry-point script. If Rez is going to be installed in edit-mode, all bin tools will be generated with the custom script, which will pre-cache the location of bin tools when the session starts if, the environment variable REZUP_EDIT_IN_PRODUCTION exists and is not empty (see davidlatwe/rezup#56 for implementation detail). You may put that env var in e.g. rezup.dev.toml like this: [env] REZUP_EDIT_IN_PRODUCTION = \"1\" [rez] name = \"rez\" url = \"/path/to/source/rez\" edit = true","title":"Production Install"},{"location":"environ/","text":"Environment Variables Name Description REZUP_ROOT_LOCAL Root path of local containers, if not defined in Recipe , default is ~/.rezup REZUP_ROOT_REMOTE Root path of remote containers, if not defined in Recipe REZUP_DEFAULT_SHELL Specify shell to use. See Command . REZUP_PROMPT For customizing shell prompt, optional. See Command . REZUP_CONTAINER Auto set, for customizing shell prompt. See Command . REZUP_USING_REMOTE Auto set, indicating where the container was sourced from. REZUP_EDIT_IN_PRODUCTION Enable production privilege for Rez that was installed in edit mode. REZUP_TEST_KEEP_TMP Preserve temp dirs in tests.","title":"Environ"},{"location":"environ/#environment-variables","text":"Name Description REZUP_ROOT_LOCAL Root path of local containers, if not defined in Recipe , default is ~/.rezup REZUP_ROOT_REMOTE Root path of remote containers, if not defined in Recipe REZUP_DEFAULT_SHELL Specify shell to use. See Command . REZUP_PROMPT For customizing shell prompt, optional. See Command . REZUP_CONTAINER Auto set, for customizing shell prompt. See Command . REZUP_USING_REMOTE Auto set, indicating where the container was sourced from. REZUP_EDIT_IN_PRODUCTION Enable production privilege for Rez that was installed in edit mode. REZUP_TEST_KEEP_TMP Preserve temp dirs in tests.","title":"Environment Variables"},{"location":"license/","text":"Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"rezup/","text":"ContainerRecipe A dict-like representation of container's recipe The recipe file of default container '.main' will be '~/rezup.toml' And for other container, it will be ~/rezup.{name}.toml for example: * ~/rezup.dev.toml -> container dev * ~/rezup.test.toml -> container test Parameters: Name Type Description Default name str Container name None Source code in rezup/recipe.py class ContainerRecipe ( BaseRecipe ): \"\"\"A dict-like representation of container's recipe The recipe file of default container '.main' will be '~/rezup.toml' And for other container, it will be `~/rezup.{name}.toml` for example: * `~/rezup.dev.toml` -> container `dev` * `~/rezup.test.toml` -> container `test` Args: name (str, optional): Container name \"\"\" REGEX = re . compile ( \"rezup.?(.*).toml\" ) RECIPES_DIR = DEFAULT_CONTAINER_RECIPES #: `DEFAULT_CONTAINER_RECIPES` def __init__ ( self , name = None ): super ( ContainerRecipe , self ) . __init__ ( name ) _name = self . _name if _name and _name != DEFAULT_CONTAINER_NAME : self . _file = \"rezup. %s .toml\" % _name else : self . _file = \"rezup.toml\" @classmethod @contextmanager def provisional_recipes ( cls , path ): \"\"\"Context for changing recipes root temporarily Container recipes should be in user's home directory by defaule, but that could be changed inside this context for the case when you need to operate on machines that have no recipe exists in home directory. ``` with ContainerRecipe.provisional_recipes(\"/to/other/recipes\"): ... ``` Args: path (str or path-like): directory path where recipes located \"\"\" default = cls . RECIPES_DIR try : cls . RECIPES_DIR = Path ( path ) yield finally : cls . RECIPES_DIR = default @classmethod def iter_recipes ( cls ): \"\"\"Iter all recipe files found in `ContainerRecipe.RECIPES_DIR` Yields: `ContainerRecipe` \"\"\" for item in cls . RECIPES_DIR . iterdir (): if not item . is_file (): continue match = cls . REGEX . search ( item . name ) if match : name = match . group ( 1 ) yield cls ( name ) def path ( self ): \"\"\"Returns the file path of this recipe Returns: pathlib.Path: The file path of this recipe \"\"\" if self . _path is None : self . _path = self . RECIPES_DIR / self . _file return self . _path def create ( self , data = None ): \"\"\"Write out recipe content into a .toml file Args: data (dict, optional): Arbitrary data to write out \"\"\" if not self . RECIPES_DIR . is_dir (): self . RECIPES_DIR . mkdir ( parents = True ) path = self . path () if data : _data = toml . load ( str ( self . DEFAULT_RECIPE )) deep_update ( _data , data ) with open ( str ( path ), \"w\" ) as f : toml . dump ( _data , f ) else : # read & write as plaintext, so the comment can be preserved with open ( str ( self . DEFAULT_RECIPE ), \"r\" ) as r : with open ( str ( path ), \"w\" ) as w : w . write ( r . read ()) self . _load () create ( self , data = None ) Write out recipe content into a .toml file Parameters: Name Type Description Default data dict Arbitrary data to write out None Source code in rezup/recipe.py def create ( self , data = None ): \"\"\"Write out recipe content into a .toml file Args: data (dict, optional): Arbitrary data to write out \"\"\" if not self . RECIPES_DIR . is_dir (): self . RECIPES_DIR . mkdir ( parents = True ) path = self . path () if data : _data = toml . load ( str ( self . DEFAULT_RECIPE )) deep_update ( _data , data ) with open ( str ( path ), \"w\" ) as f : toml . dump ( _data , f ) else : # read & write as plaintext, so the comment can be preserved with open ( str ( self . DEFAULT_RECIPE ), \"r\" ) as r : with open ( str ( path ), \"w\" ) as w : w . write ( r . read ()) self . _load () iter_recipes () classmethod Iter all recipe files found in ContainerRecipe.RECIPES_DIR Yields: Type Description ContainerRecipe Source code in rezup/recipe.py @classmethod def iter_recipes ( cls ): \"\"\"Iter all recipe files found in `ContainerRecipe.RECIPES_DIR` Yields: `ContainerRecipe` \"\"\" for item in cls . RECIPES_DIR . iterdir (): if not item . is_file (): continue match = cls . REGEX . search ( item . name ) if match : name = match . group ( 1 ) yield cls ( name ) path ( self ) Returns the file path of this recipe Returns: Type Description pathlib.Path The file path of this recipe Source code in rezup/recipe.py def path ( self ): \"\"\"Returns the file path of this recipe Returns: pathlib.Path: The file path of this recipe \"\"\" if self . _path is None : self . _path = self . RECIPES_DIR / self . _file return self . _path provisional_recipes ( cls , path ) classmethod Context for changing recipes root temporarily Container recipes should be in user's home directory by defaule, but that could be changed inside this context for the case when you need to operate on machines that have no recipe exists in home directory. with ContainerRecipe.provisional_recipes(\"/to/other/recipes\"): ... Parameters: Name Type Description Default path str or path-like directory path where recipes located required Source code in rezup/recipe.py @classmethod @contextmanager def provisional_recipes ( cls , path ): \"\"\"Context for changing recipes root temporarily Container recipes should be in user's home directory by defaule, but that could be changed inside this context for the case when you need to operate on machines that have no recipe exists in home directory. ``` with ContainerRecipe.provisional_recipes(\"/to/other/recipes\"): ... ``` Args: path (str or path-like): directory path where recipes located \"\"\" default = cls . RECIPES_DIR try : cls . RECIPES_DIR = Path ( path ) yield finally : cls . RECIPES_DIR = default get_container_root Internal use Get container root path from recipe # rezup.foo.toml [root] local = \"\" remote = \"/path/to/remote/containers\" If the recipe represents the above example recipe file, container named foo will have local root set to rezup.recipe.DEFAULT_CONTAINER_RECIPES , unless environ variable REZUP_ROOT_LOCAL has value. And the remote root will set to /path/to/remote/containers . Parameters: Name Type Description Default recipe `ContainerRecipe` The container recipe to lookup from. required remote bool Fetch remote root if True, otherwise local. False Returns: Type Description `pathlib.Path` Container root path, local or remote one. Source code in rezup/container.py def get_container_root ( recipe , remote = False ): \"\"\"Get container root path from recipe ```toml # rezup.foo.toml [root] local = \"\" remote = \"/path/to/remote/containers\" ``` If the `recipe` represents the above example recipe file, container named `foo` will have local root set to `rezup.recipe.DEFAULT_CONTAINER_RECIPES`, unless environ variable `REZUP_ROOT_LOCAL` has value. And the remote root will set to `/path/to/remote/containers`. Args: recipe (`ContainerRecipe`): The container recipe to lookup from. remote (bool): Fetch remote root if True, otherwise local. Returns: `pathlib.Path`: Container root path, local or remote one. \"\"\" data = recipe . data () if remote : remote = \\ data [ \"root\" ][ \"remote\" ] \\ or os . getenv ( \"REZUP_ROOT_REMOTE\" ) return Path ( norm_path ( remote )) if remote else None else : local = \\ data [ \"root\" ][ \"local\" ] \\ or os . getenv ( \"REZUP_ROOT_LOCAL\" ) \\ or \"~/.rezup\" return Path ( norm_path ( local )) Container Timestamp ordered virtual environment stack A Rez venv provider, that allows updating venv continuously without affecting any existing consumer. In filesystem, a container is a folder that has at least one Rez venv installation exists, and those Rez venv folders ( Revision ) are named by timestamp, so when the container is being asked for a venv to use, the current latest available one will be sorted out. The location of the container can be set with env var REZUP_ROOT_LOCAL or ~/.rezup will be used by default. For centralize management in production, one remote container can be defined with an env var REZUP_ROOT_REMOTE . The remote container only contains the venv installation manifest file, and when being asked, a venv will be created locally or re-used if same revision exists in local. Parameters: Name Type Description Default name `str` Container name, use Container.DEFAULT_NAME if not given. None recipe `ContainerRecipe` A ContainerRecipe object to help constructing container, will look into ContainerRecipe.RECIPES_DIR if not given. None force_local `bool` Default False . Ignore linking remote even if the remote path has set, always link to local if True . False Source code in rezup/container.py class Container : \"\"\"Timestamp ordered virtual environment stack A Rez venv provider, that allows updating venv continuously without affecting any existing consumer. In filesystem, a container is a folder that has at least one Rez venv installation exists, and those Rez venv folders (`Revision`) are named by timestamp, so when the container is being asked for a venv to use, the current latest available one will be sorted out. The location of the container can be set with env var `REZUP_ROOT_LOCAL` or `~/.rezup` will be used by default. For centralize management in production, one remote container can be defined with an env var `REZUP_ROOT_REMOTE`. The remote container only contains the venv installation manifest file, and when being asked, a venv will be created locally or re-used if same revision exists in local. Args: name (`str`, optional): Container name, use `Container.DEFAULT_NAME` if not given. recipe (`ContainerRecipe`, optional): A `ContainerRecipe` object to help constructing container, will look into `ContainerRecipe.RECIPES_DIR` if not given. force_local (`bool`, optional): Default `False`. Ignore linking remote even if the remote path has set, always link to local if `True`. \"\"\" DEFAULT_NAME = DEFAULT_CONTAINER_NAME #: `rezup.recipe.DEFAULT_CONTAINER_NAME` def __init__ ( self , name = None , recipe = None , force_local = False ): name = name or self . DEFAULT_NAME recipe = recipe or ContainerRecipe ( name ) local_root = get_container_root ( recipe , remote = False ) remote_root = get_container_root ( recipe , remote = True ) if force_local : root = local_root else : root = remote_root or local_root self . _remote = root == remote_root self . _recipe = recipe self . _name = name self . _root = root self . _path = root / name def __repr__ ( self ): return \" %s (remote= %d , name= %r , path= %r )\" % ( self . __class__ . __name__ , int ( self . is_remote ()), self . name (), self . _path . resolve (), ) @classmethod def create ( cls , name , force_local = False ): \"\"\"Create container from recipe. Args: name (str): The name of container. force_local (bool): Create as local if True, or try remote. Returns: `Container`: A container instance. \"\"\" recipe = ContainerRecipe ( name ) _log . debug ( \"Sourcing recipe from: %s \" % recipe ) if not recipe . is_file (): _log . debug ( \"Recipe file not exists, creating default..\" ) recipe . create () return Container ( name , recipe , force_local ) def root ( self ): \"\"\" Returns: `pathlib.Path`: Path to where this container is located. \"\"\" return self . _root def name ( self ): \"\"\" Returns: str: Container name. \"\"\" return self . _name def path ( self ): \"\"\" Returns: `pathlib.Path`: Full path of this container. \"\"\" return self . _path def recipe ( self ): \"\"\" Returns: `ContainerRecipe`: The recipe instance that binds to this container. \"\"\" return self . _recipe def libs ( self ): \"\"\" Returns: `pathlib.Path`: Path to this container's shared libraries. \"\"\" return self . _path / \"libs\" def revisions ( self ): \"\"\" Returns: `pathlib.Path`: Path to this container's revisions. \"\"\" return self . _path / \"revisions\" def is_exists ( self ): \"\"\" Returns: bool: Return `True` if this container exists. \"\"\" return self . _path . is_dir () def is_empty ( self ): \"\"\" Returns: bool: Return `True` if this container has no valid revisions. \"\"\" return not bool ( next ( self . iter_revision (), None )) def is_remote ( self ): \"\"\" Returns: bool: Return `True` if this container is linked to remote side. \"\"\" return self . _remote def purge ( self ): if self . is_exists (): revision = self . get_latest_revision ( only_ready = False ) if not revision : # TODO: don't remove it immediately, mark as purged and # remove it when $REZUP_CLEAN_AFTER meet rmtree ( self . _path ) else : # TODO: should have better exception type # TODO: need to check revision is in use raise Exception ( \"Revision is creating.\" ) # keep tidy, try remove the root of containers if it's now empty root = self . root () if root . is_dir () and not next ( root . iterdir (), None ): rmtree ( root ) def iter_revision ( self , validate = True , latest_first = True ): \"\"\"Iterating revisions from this container. Args: validate (bool, optional): Default `True`. Only yield revisions that are valid if `True`. latest_first (bool): Default `True`. Yield revisions based on it's directory name (timestamp string) in descending order, or ascending if `False`. Yields: Revision: `Revision` instances that match the condition. \"\"\" _log . debug ( \"Iterating revisions in container %s ..\" % self ) if not self . is_exists (): _log . debug ( \"Container %r not exists.\" % self . name ()) return revisions_root = Revision . compose_path ( container = self ) if not revisions_root . is_dir (): _log . debug ( \"Revision root is not a directory: %s \" % revisions_root ) return revisions_root = str ( revisions_root ) for entry in sorted ( os . listdir ( revisions_root ), reverse = latest_first ): revision = Revision ( container = self , dirname = entry ) _log . debug ( \"... %s \" % revision ) if not validate or revision . is_valid (): yield revision def get_latest_revision ( self , only_ready = True ): \"\"\"Get latest revision from this container. Args: only_ready (bool): Default `True`. Include revisions that are not in ready state if `False`. Returns: Revision: An instance of `Revision` if found, or `None`. \"\"\" for revision in self . iter_revision (): if not only_ready or revision . is_ready (): _log . debug ( \"Found latest revision.\" ) return revision def get_revision_by_time ( self , timestamp , fallback = False , only_ready = True ): \"\"\"Returns a revision that match the timestamp Args: timestamp (datetime.datetime): a time for matching revision fallback (bool): If True, accept earlier revision when no exact matched only_ready (bool): Include revisions that are not in ready state if False Returns: Revision: An instance of `Revision` if found, or `None`. \"\"\" for revision in self . iter_revision (): if not only_ready or revision . is_ready (): if ( revision . timestamp () == timestamp or ( fallback and revision . timestamp () <= timestamp )): _log . debug ( \"Found time matched revision.\" ) return revision _log . debug ( \"No time matched revision found.\" ) def new_revision ( self ): \"\"\"Create a new revision Returns: Revision: An instance of `Revision` that just created. \"\"\" return Revision . create ( self ) create ( name , force_local = False ) classmethod Create container from recipe. Parameters: Name Type Description Default name str The name of container. required force_local bool Create as local if True, or try remote. False Returns: Type Description `Container` A container instance. Source code in rezup/container.py @classmethod def create ( cls , name , force_local = False ): \"\"\"Create container from recipe. Args: name (str): The name of container. force_local (bool): Create as local if True, or try remote. Returns: `Container`: A container instance. \"\"\" recipe = ContainerRecipe ( name ) _log . debug ( \"Sourcing recipe from: %s \" % recipe ) if not recipe . is_file (): _log . debug ( \"Recipe file not exists, creating default..\" ) recipe . create () return Container ( name , recipe , force_local ) get_latest_revision ( self , only_ready = True ) Get latest revision from this container. Parameters: Name Type Description Default only_ready bool Default True . Include revisions that are not in ready state if False . True Returns: Type Description Revision An instance of Revision if found, or None . Source code in rezup/container.py def get_latest_revision ( self , only_ready = True ): \"\"\"Get latest revision from this container. Args: only_ready (bool): Default `True`. Include revisions that are not in ready state if `False`. Returns: Revision: An instance of `Revision` if found, or `None`. \"\"\" for revision in self . iter_revision (): if not only_ready or revision . is_ready (): _log . debug ( \"Found latest revision.\" ) return revision get_revision_by_time ( self , timestamp , fallback = False , only_ready = True ) Returns a revision that match the timestamp Parameters: Name Type Description Default timestamp datetime.datetime a time for matching revision required fallback bool If True, accept earlier revision when no exact matched False only_ready bool Include revisions that are not in ready state if False True Returns: Type Description Revision An instance of Revision if found, or None . Source code in rezup/container.py def get_revision_by_time ( self , timestamp , fallback = False , only_ready = True ): \"\"\"Returns a revision that match the timestamp Args: timestamp (datetime.datetime): a time for matching revision fallback (bool): If True, accept earlier revision when no exact matched only_ready (bool): Include revisions that are not in ready state if False Returns: Revision: An instance of `Revision` if found, or `None`. \"\"\" for revision in self . iter_revision (): if not only_ready or revision . is_ready (): if ( revision . timestamp () == timestamp or ( fallback and revision . timestamp () <= timestamp )): _log . debug ( \"Found time matched revision.\" ) return revision _log . debug ( \"No time matched revision found.\" ) is_empty ( self ) Returns: Type Description bool Return True if this container has no valid revisions. Source code in rezup/container.py def is_empty ( self ): \"\"\" Returns: bool: Return `True` if this container has no valid revisions. \"\"\" return not bool ( next ( self . iter_revision (), None )) is_exists ( self ) Returns: Type Description bool Return True if this container exists. Source code in rezup/container.py def is_exists ( self ): \"\"\" Returns: bool: Return `True` if this container exists. \"\"\" return self . _path . is_dir () is_remote ( self ) Returns: Type Description bool Return True if this container is linked to remote side. Source code in rezup/container.py def is_remote ( self ): \"\"\" Returns: bool: Return `True` if this container is linked to remote side. \"\"\" return self . _remote iter_revision ( self , validate = True , latest_first = True ) Iterating revisions from this container. Parameters: Name Type Description Default validate bool Default True . Only yield revisions that are valid if True . True latest_first bool Default True . Yield revisions based on it's directory name (timestamp string) in descending order, or ascending if False . True Yields: Type Description Revision Revision instances that match the condition. Source code in rezup/container.py def iter_revision ( self , validate = True , latest_first = True ): \"\"\"Iterating revisions from this container. Args: validate (bool, optional): Default `True`. Only yield revisions that are valid if `True`. latest_first (bool): Default `True`. Yield revisions based on it's directory name (timestamp string) in descending order, or ascending if `False`. Yields: Revision: `Revision` instances that match the condition. \"\"\" _log . debug ( \"Iterating revisions in container %s ..\" % self ) if not self . is_exists (): _log . debug ( \"Container %r not exists.\" % self . name ()) return revisions_root = Revision . compose_path ( container = self ) if not revisions_root . is_dir (): _log . debug ( \"Revision root is not a directory: %s \" % revisions_root ) return revisions_root = str ( revisions_root ) for entry in sorted ( os . listdir ( revisions_root ), reverse = latest_first ): revision = Revision ( container = self , dirname = entry ) _log . debug ( \"... %s \" % revision ) if not validate or revision . is_valid (): yield revision libs ( self ) Returns: Type Description `pathlib.Path` Path to this container's shared libraries. Source code in rezup/container.py def libs ( self ): \"\"\" Returns: `pathlib.Path`: Path to this container's shared libraries. \"\"\" return self . _path / \"libs\" name ( self ) Returns: Type Description str Container name. Source code in rezup/container.py def name ( self ): \"\"\" Returns: str: Container name. \"\"\" return self . _name new_revision ( self ) Create a new revision Returns: Type Description Revision An instance of Revision that just created. Source code in rezup/container.py def new_revision ( self ): \"\"\"Create a new revision Returns: Revision: An instance of `Revision` that just created. \"\"\" return Revision . create ( self ) path ( self ) Returns: Type Description `pathlib.Path` Full path of this container. Source code in rezup/container.py def path ( self ): \"\"\" Returns: `pathlib.Path`: Full path of this container. \"\"\" return self . _path recipe ( self ) Returns: Type Description `ContainerRecipe` The recipe instance that binds to this container. Source code in rezup/container.py def recipe ( self ): \"\"\" Returns: `ContainerRecipe`: The recipe instance that binds to this container. \"\"\" return self . _recipe revisions ( self ) Returns: Type Description `pathlib.Path` Path to this container's revisions. Source code in rezup/container.py def revisions ( self ): \"\"\" Returns: `pathlib.Path`: Path to this container's revisions. \"\"\" return self . _path / \"revisions\" root ( self ) Returns: Type Description `pathlib.Path` Path to where this container is located. Source code in rezup/container.py def root ( self ): \"\"\" Returns: `pathlib.Path`: Path to where this container is located. \"\"\" return self . _root Revision Parameters: Name Type Description Default container Container The container that holds this revision required dirname str Directory name of this revision, should be a timestamp string if given. None Source code in rezup/container.py class Revision : \"\"\" Args: container (Container): The container that holds this revision dirname (str, optional): Directory name of this revision, should be a timestamp string if given. \"\"\" def __init__ ( self , container , dirname = None ): dirname = str ( dirname or time . time ()) self . _container = container self . _dirname = dirname self . _path = self . compose_path ( container , dirname ) self . _timestamp = None self . _is_valid = None self . _metadata = None self . _recipe = RevisionRecipe ( self ) self . _metadata_path = self . _path / \"revision.json\" self . _is_pulled = False def __repr__ ( self ): return \" %s (valid= %d , ready= %d , remote= %d , time= %s , path= %r )\" % ( self . __class__ . __name__ , int ( self . is_valid ()), int ( self . is_ready ()), int ( self . is_remote ()), self . time_str () or \"?\" , self . _path . resolve (), ) def __eq__ ( self , other ): if not isinstance ( other , type ( self )): return False return self . _container . name () == other . _container . name () \\ and self . timestamp () == other . timestamp () @classmethod def compose_path ( cls , container , dirname = None ): path = container . revisions () if dirname : path /= dirname return path @classmethod def create ( cls , container ): revision = cls ( container = container ) revision . _write () return revision def _write ( self , pulling = None ): \"\"\"Sourcing recipe and create a revision Args: pulling (Revision, optional): If given, pulling recipe from that revision, usually a remote one. \"\"\" _log . info ( \"Creating revision..\" ) recipe = self . _recipe makedirs ( self . _path ) # write revision recipe if pulling is None : _log . info ( \"Recipe sourced from: %s \" % self . _container . recipe ()) recipe . create () else : _log . debug ( \"Pulling recipe from: %s \" % pulling ) recipe . pull ( pulling ) if not self . is_valid (): raise Exception ( \"Invalid new revision, this is a bug.\" ) # manifest rez_ = Tool ( recipe [ \"rez\" ]) extensions = [ Tool ( d ) for d in recipe . get ( \"extension\" , []) if d ] shared_lib = recipe . get ( \"shared\" ) _log . info ( \"Recipe loaded.\" ) _log . debug ( \" Rez: %s \" % rez_ . url ) _log . debug ( \" Extension: \" + \", \" . join ([ e . name for e in extensions ])) _log . debug ( \"Shared-lib: %s \" % shared_lib ) # install, if at local if not self . _container . is_remote (): self . _install ( rez_ , extensions , shared_lib ) # save metadata, mark revision as ready with open ( str ( self . _metadata_path ), \"w\" ) as f : # metadata f . write ( json . dumps ({ \"rezup_version\" : __version__ , \"creator\" : getpass . getuser (), \"hostname\" : socket . gethostname (), \"revision_path\" : str ( self . _path ), \"venvs\" : [ \"rez\" ] + [ t . name for t in extensions if t . isolation ], }, indent = 4 )) _log . info ( \"Revision created: %s \" % self ) def _install ( self , rez_ , extensions = None , shared_lib = None ): \"\"\"Construct Rez virtual environment by recipe \"\"\" _log . debug ( \"Installing..\" ) pip_entry = self . _recipe . get ( \"pip\" ) extensions = extensions or [] installer = Installer ( self , pip_opt = pip_entry . get ( \"options\" ), pip_env = pip_entry . get ( \"env\" ), ) installer . install_rez ( rez_ ) if shared_lib : warnings . warn ( \"Shared-lib section is about to be deprecated, \" \"use 'rez.lib' or 'extension.lib' section instead. \" \"See https://github.com/davidlatwe/rezup/issues/62\" , DeprecationWarning ) installer . create_shared_lib ( name = shared_lib [ \"name\" ], requires = shared_lib [ \"requires\" ]) for ext in extensions : installer . install_extension ( ext ) def validate ( self ): is_valid = True seconds = float ( self . _dirname ) timestamp = datetime . fromtimestamp ( seconds ) if self . _recipe . is_file (): self . _timestamp = timestamp else : is_valid = False return is_valid def is_valid ( self ): if self . _is_valid is None : try : self . _is_valid = self . validate () except ( OSError , ValueError ): self . _is_valid = False return self . _is_valid def is_ready ( self ): return self . _metadata_path . is_file () def is_remote ( self ): return self . _container . is_remote () def dirname ( self ): return self . _dirname def path ( self ): return self . _path def timestamp ( self ): return self . _timestamp def time_str ( self ): return self . _timestamp . strftime ( \" %d .%b.%y %H:%M\" ) \\ if self . _timestamp else \"\" def container ( self ): return self . _container def metadata ( self ): if self . is_ready (): if self . _metadata is None : with open ( str ( self . _metadata_path ), \"r\" ) as f : self . _metadata = json . load ( f ) return self . _metadata def recipe ( self ): if self . is_valid (): return self . _recipe def recipe_env ( self ): _platform = platform . system () . lower () recipe = self . recipe () or {} env = {} def load_env ( ** kwargs ): return { k : v for k , v in dotenv_values ( ** kwargs ) . items () if v is not None # exclude config section line } def file_loader ( d ): return [ d [ k ] for k in sorted ([ k for k , v in d . items () if isinstance ( v , string_types )])] dot_env = recipe . get ( \"dotenv\" ) if dot_env : # non platform specific dotenv env_files = file_loader ( dot_env ) if isinstance ( dot_env . get ( _platform ), dict ): # platform specific dotenv env_files += file_loader ( dot_env [ _platform ]) for file in env_files : env . update ( load_env ( dotenv_path = file )) recipe_env = recipe . get ( \"env\" ) if recipe_env : stream = StringIO () _parser = ConfigParser () _parser . optionxform = str # to prevent turning keys into lowercase _parser . read_dict ({ \"env\" : recipe_env }) _parser . write ( stream ) stream . seek ( 0 ) # must reset buffer env . update ( load_env ( stream = stream )) env . update ({ \"REZUP_CONTAINER\" : self . _container . name (), \"REZUP_USING_REMOTE\" : \"yes\" if self . _is_pulled else \"\" , }) return env def purge ( self ): if self . is_valid (): # TODO: don't remove it immediately, mark as purged and # remove it when $REZUP_CLEAN_AFTER meet rmtree ( self . _path ) def iter_backward ( self ): for revision in self . _container . iter_revision ( latest_first = True ): if revision . timestamp () < self . _timestamp : yield revision def iter_forward ( self ): for revision in self . _container . iter_revision ( latest_first = False ): if revision . timestamp () > self . _timestamp : yield revision def pull ( self , check_out = True , fallback = False ): \"\"\"Return corresponding local side revision If the revision is from remote container, calling this method will find a timestamp matched local revision and create one if not found by default. If the revision is from local container, return `self`. Args: check_out (bool, optional): When no matched local revision, create one if True or just return None at the end. Default is True. fallback (bool, optional) Returns: Revision or None \"\"\" if not self . is_remote (): return self # get local _con_name = self . _container . name () _con_recipe = self . _container . recipe () # careful, this affect's root local = Container ( _con_name , recipe = _con_recipe , force_local = True ) rev = local . get_revision_by_time ( self . _timestamp , fallback = fallback , only_ready = True ) _allow_create = rev is None and check_out _did_fallback = rev . timestamp () != self . _timestamp if rev else False if not fallback and _allow_create : _log . info ( \"Pulling from remote container: %s \" % self . _container ) rev = Revision ( container = local , dirname = self . _dirname ) rev . _write ( pulling = self ) if fallback and _did_fallback : _log . warning ( \"Local revision at exact time ( %s ) is not ready, \" \"fallback to %s \" % ( self . time_str (), rev ) ) if rev is not None : rev . _is_pulled = True return rev def spawn_shell ( self , command = None ): \"\"\"Spawn a sub-shell Args: command (list, optional): Shell script file with args or commands. If given, the sub-shell will not be interactive. Returns: subprocess.Popen Raises: ContainerError \"\"\" if not self . is_valid (): raise ContainerError ( \"Cannot use invalid revision.\" ) if not self . is_ready (): raise ContainerError ( \"Revision is not ready to be used.\" ) if self . is_remote (): # use local revision = self . pull () if revision is None : raise ContainerError ( \"No revision pulled.\" ) if not revision . is_ready (): raise ContainerError ( \"Revision is not ready to be used.\" ) return revision . spawn_shell ( command = command ) else : # Launch subprocess environment = self . _compose_env () shell_name , shell_exec = self . _get_shell () if command : # run command and exit if command [ 0 ] == \".\" : cmd = command else : exe = command [ 0 ] exe = shell . which ( exe , env = environment ) or exe cmd = [ exe ] + command [ 1 :] else : # interactive shell _con_name = self . _container . name () _con_from = \"remote\" if self . _is_pulled else \"local\" prompt = \"rezup ( %s / %s ) \" % ( _con_name , _con_from ) prompt = shell . format_prompt_code ( prompt , shell_name ) environment . update ({ \"REZUP_PROMPT\" : os . getenv ( \"REZUP_PROMPT\" , prompt ), }) cmd = shell . get_launch_cmd ( shell_name , shell_exec , interactive = True , ) popen = subprocess . Popen ( cmd , env = environment ) return popen def use ( self , command = None , wait = True ): \"\"\"Run a sub-shell Args: command (list, optional): Shell script with args or commands. If given, the sub-shell will not be interactive. wait (bool, optional): Whether to wait `command` finish or not, default True. Returns: int: subprocess return code, will always return 0 if `command` is given and `wait` is False. \"\"\" block = not command popen = self . spawn_shell ( command = command ) if block or wait : stdout , stderr = popen . communicate () return popen . returncode else : return 0 def _compose_env ( self ): env = os . environ . copy () env . update ( self . recipe_env () or {}) env [ \"PATH\" ] = os . pathsep . join ([ os . pathsep . join ([ str ( p ) for p in self . production_bin_dirs ()]), env [ \"PATH\" ] ]) # use `pythonfinder` package if need to exclude python from PATH return env def _get_shell ( self ): shell_name = os . getenv ( \"REZUP_DEFAULT_SHELL\" ) if shell_name : shell_exec = shell_name shell_name , ext = os . path . splitext ( os . path . basename ( shell_name )) shell_name = shell_name . lower () else : shell_name , shell_exec = shell . get_current_shell () shell_exec = shell_exec or shell_name return shell_name , shell_exec def _require_local ( method ): # noqa \"\"\"Decorator for ensuring local revision exists before action \"\"\" @functools . wraps ( method ) # noqa def wrapper ( self , * args , ** kwargs ): if not self . is_remote (): return method ( self , * args , ** kwargs ) # noqa check_out = bool ( os . getenv ( \"REZUP_ALWAYS_CHECKOUT\" )) revision = self . pull ( check_out = check_out ) if revision is None : raise ContainerError ( \"This revision is from remote container, no matched found \" \"in local. Possible not been pulled into local yet.\" ) return getattr ( revision , method . __name__ )( self , * args , ** kwargs ) return wrapper @_require_local # noqa def locate_rez_lib ( self , venv_session = None ): \"\"\"Returns rez module location in this revision Returns: pathlib.Path or None if not found. \"\"\" if venv_session is None : venv_path = self . path () / \"venv\" / \"rez\" venv_session = virtualenv . session_via_cli ( args = [ str ( venv_path )]) venv_lib = venv_session . creator . purelib # rez may get installed in edit mode, try short route first egg_link = venv_lib / \"rez.egg-link\" if egg_link . is_file (): with open ( str ( egg_link ), \"r\" ) as f : package_location = f . readline () . strip () if os . path . isdir ( package_location ): return Path ( package_location ) for importer , modname , pkg in pkgutil . walk_packages ([ str ( venv_lib )]): if pkg and modname == \"rez\" : loader = importer . find_module ( modname ) try : path = loader . path # SourceFileLoader return Path ( path ) . parent . parent except AttributeError : path = loader . filename # ImpLoader, py2 return Path ( path ) . parent @_require_local # noqa def get_rez_version ( self , venv_session = None ): \"\"\"Returns rez version installed in this revision Returns: str or None if not found. \"\"\" rez_location = self . locate_rez_lib ( venv_session ) if rez_location is None : return version_py = rez_location / \"rez\" / \"utils\" / \"_version.py\" if version_py . is_file (): _locals = { \"_rez_version\" : \"\" } with open ( str ( version_py )) as f : exec ( f . read (), globals (), _locals ) return _locals [ \"_rez_version\" ] @_require_local # noqa def production_bin_dir ( self , venv_name ): \"\"\"Returns production bin scripts dir in this revision Returns: pathlib.Path, but the directory may not exists. \"\"\" bin_dirname = \"Scripts\" if platform . system () == \"Windows\" else \"bin\" venv_bin_dir = self . path () / \"venv\" / venv_name / bin_dirname return venv_bin_dir / \"rez\" @_require_local # noqa def production_bin_dirs ( self ): bin_dirs = [] metadata = self . metadata () if metadata and not metadata . get ( \"rezup_version\" ): # rezup-1.x _log . debug ( \"Is a 'rezup-1.x' styled revision.\" ) bin_dirs . append ( self . _path / \"bin\" ) else : # rezup-2.x _log . debug ( \"Is a 'rezup-2.x' styled revision.\" ) for venv_name in metadata . get ( \"venvs\" , []): bin_dirs . append ( self . production_bin_dir ( venv_name )) return bin_dirs get_rez_version ( self , venv_session = None ) Returns rez version installed in this revision Returns: Type Description str or None if not found. Source code in rezup/container.py @_require_local # noqa def get_rez_version ( self , venv_session = None ): \"\"\"Returns rez version installed in this revision Returns: str or None if not found. \"\"\" rez_location = self . locate_rez_lib ( venv_session ) if rez_location is None : return version_py = rez_location / \"rez\" / \"utils\" / \"_version.py\" if version_py . is_file (): _locals = { \"_rez_version\" : \"\" } with open ( str ( version_py )) as f : exec ( f . read (), globals (), _locals ) return _locals [ \"_rez_version\" ] locate_rez_lib ( self , venv_session = None ) Returns rez module location in this revision Returns: Type Description pathlib.Path or None if not found. Source code in rezup/container.py @_require_local # noqa def locate_rez_lib ( self , venv_session = None ): \"\"\"Returns rez module location in this revision Returns: pathlib.Path or None if not found. \"\"\" if venv_session is None : venv_path = self . path () / \"venv\" / \"rez\" venv_session = virtualenv . session_via_cli ( args = [ str ( venv_path )]) venv_lib = venv_session . creator . purelib # rez may get installed in edit mode, try short route first egg_link = venv_lib / \"rez.egg-link\" if egg_link . is_file (): with open ( str ( egg_link ), \"r\" ) as f : package_location = f . readline () . strip () if os . path . isdir ( package_location ): return Path ( package_location ) for importer , modname , pkg in pkgutil . walk_packages ([ str ( venv_lib )]): if pkg and modname == \"rez\" : loader = importer . find_module ( modname ) try : path = loader . path # SourceFileLoader return Path ( path ) . parent . parent except AttributeError : path = loader . filename # ImpLoader, py2 return Path ( path ) . parent production_bin_dir ( self , venv_name ) Returns production bin scripts dir in this revision Returns: Type Description pathlib.Path, but the directory may not exists. Source code in rezup/container.py @_require_local # noqa def production_bin_dir ( self , venv_name ): \"\"\"Returns production bin scripts dir in this revision Returns: pathlib.Path, but the directory may not exists. \"\"\" bin_dirname = \"Scripts\" if platform . system () == \"Windows\" else \"bin\" venv_bin_dir = self . path () / \"venv\" / venv_name / bin_dirname return venv_bin_dir / \"rez\" pull ( self , check_out = True , fallback = False ) Return corresponding local side revision If the revision is from remote container, calling this method will find a timestamp matched local revision and create one if not found by default. If the revision is from local container, return self . Parameters: Name Type Description Default check_out bool When no matched local revision, create one if True or just return None at the end. Default is True. True Returns: Type Description Revision or None Source code in rezup/container.py def pull ( self , check_out = True , fallback = False ): \"\"\"Return corresponding local side revision If the revision is from remote container, calling this method will find a timestamp matched local revision and create one if not found by default. If the revision is from local container, return `self`. Args: check_out (bool, optional): When no matched local revision, create one if True or just return None at the end. Default is True. fallback (bool, optional) Returns: Revision or None \"\"\" if not self . is_remote (): return self # get local _con_name = self . _container . name () _con_recipe = self . _container . recipe () # careful, this affect's root local = Container ( _con_name , recipe = _con_recipe , force_local = True ) rev = local . get_revision_by_time ( self . _timestamp , fallback = fallback , only_ready = True ) _allow_create = rev is None and check_out _did_fallback = rev . timestamp () != self . _timestamp if rev else False if not fallback and _allow_create : _log . info ( \"Pulling from remote container: %s \" % self . _container ) rev = Revision ( container = local , dirname = self . _dirname ) rev . _write ( pulling = self ) if fallback and _did_fallback : _log . warning ( \"Local revision at exact time ( %s ) is not ready, \" \"fallback to %s \" % ( self . time_str (), rev ) ) if rev is not None : rev . _is_pulled = True return rev spawn_shell ( self , command = None ) Spawn a sub-shell Parameters: Name Type Description Default command list Shell script file with args or commands. If given, the sub-shell will not be interactive. None Returns: Type Description subprocess.Popen Source code in rezup/container.py def spawn_shell ( self , command = None ): \"\"\"Spawn a sub-shell Args: command (list, optional): Shell script file with args or commands. If given, the sub-shell will not be interactive. Returns: subprocess.Popen Raises: ContainerError \"\"\" if not self . is_valid (): raise ContainerError ( \"Cannot use invalid revision.\" ) if not self . is_ready (): raise ContainerError ( \"Revision is not ready to be used.\" ) if self . is_remote (): # use local revision = self . pull () if revision is None : raise ContainerError ( \"No revision pulled.\" ) if not revision . is_ready (): raise ContainerError ( \"Revision is not ready to be used.\" ) return revision . spawn_shell ( command = command ) else : # Launch subprocess environment = self . _compose_env () shell_name , shell_exec = self . _get_shell () if command : # run command and exit if command [ 0 ] == \".\" : cmd = command else : exe = command [ 0 ] exe = shell . which ( exe , env = environment ) or exe cmd = [ exe ] + command [ 1 :] else : # interactive shell _con_name = self . _container . name () _con_from = \"remote\" if self . _is_pulled else \"local\" prompt = \"rezup ( %s / %s ) \" % ( _con_name , _con_from ) prompt = shell . format_prompt_code ( prompt , shell_name ) environment . update ({ \"REZUP_PROMPT\" : os . getenv ( \"REZUP_PROMPT\" , prompt ), }) cmd = shell . get_launch_cmd ( shell_name , shell_exec , interactive = True , ) popen = subprocess . Popen ( cmd , env = environment ) return popen use ( self , command = None , wait = True ) Run a sub-shell Parameters: Name Type Description Default command list Shell script with args or commands. If given, the sub-shell will not be interactive. None wait bool Whether to wait command finish or not, default True. True Returns: Type Description int subprocess return code, will always return 0 if command is given and wait is False. Source code in rezup/container.py def use ( self , command = None , wait = True ): \"\"\"Run a sub-shell Args: command (list, optional): Shell script with args or commands. If given, the sub-shell will not be interactive. wait (bool, optional): Whether to wait `command` finish or not, default True. Returns: int: subprocess return code, will always return 0 if `command` is given and `wait` is False. \"\"\" block = not command popen = self . spawn_shell ( command = command ) if block or wait : stdout , stderr = popen . communicate () return popen . returncode else : return 0 ContainerError Any error that related to the container Source code in rezup/exceptions.py class ContainerError ( Exception ): \"\"\"Any error that related to the container\"\"\" pass","title":"rezup"},{"location":"rezup/#_1","text":"","title":""},{"location":"rezup/#containerrecipe","text":"A dict-like representation of container's recipe The recipe file of default container '.main' will be '~/rezup.toml' And for other container, it will be ~/rezup.{name}.toml for example: * ~/rezup.dev.toml -> container dev * ~/rezup.test.toml -> container test Parameters: Name Type Description Default name str Container name None Source code in rezup/recipe.py class ContainerRecipe ( BaseRecipe ): \"\"\"A dict-like representation of container's recipe The recipe file of default container '.main' will be '~/rezup.toml' And for other container, it will be `~/rezup.{name}.toml` for example: * `~/rezup.dev.toml` -> container `dev` * `~/rezup.test.toml` -> container `test` Args: name (str, optional): Container name \"\"\" REGEX = re . compile ( \"rezup.?(.*).toml\" ) RECIPES_DIR = DEFAULT_CONTAINER_RECIPES #: `DEFAULT_CONTAINER_RECIPES` def __init__ ( self , name = None ): super ( ContainerRecipe , self ) . __init__ ( name ) _name = self . _name if _name and _name != DEFAULT_CONTAINER_NAME : self . _file = \"rezup. %s .toml\" % _name else : self . _file = \"rezup.toml\" @classmethod @contextmanager def provisional_recipes ( cls , path ): \"\"\"Context for changing recipes root temporarily Container recipes should be in user's home directory by defaule, but that could be changed inside this context for the case when you need to operate on machines that have no recipe exists in home directory. ``` with ContainerRecipe.provisional_recipes(\"/to/other/recipes\"): ... ``` Args: path (str or path-like): directory path where recipes located \"\"\" default = cls . RECIPES_DIR try : cls . RECIPES_DIR = Path ( path ) yield finally : cls . RECIPES_DIR = default @classmethod def iter_recipes ( cls ): \"\"\"Iter all recipe files found in `ContainerRecipe.RECIPES_DIR` Yields: `ContainerRecipe` \"\"\" for item in cls . RECIPES_DIR . iterdir (): if not item . is_file (): continue match = cls . REGEX . search ( item . name ) if match : name = match . group ( 1 ) yield cls ( name ) def path ( self ): \"\"\"Returns the file path of this recipe Returns: pathlib.Path: The file path of this recipe \"\"\" if self . _path is None : self . _path = self . RECIPES_DIR / self . _file return self . _path def create ( self , data = None ): \"\"\"Write out recipe content into a .toml file Args: data (dict, optional): Arbitrary data to write out \"\"\" if not self . RECIPES_DIR . is_dir (): self . RECIPES_DIR . mkdir ( parents = True ) path = self . path () if data : _data = toml . load ( str ( self . DEFAULT_RECIPE )) deep_update ( _data , data ) with open ( str ( path ), \"w\" ) as f : toml . dump ( _data , f ) else : # read & write as plaintext, so the comment can be preserved with open ( str ( self . DEFAULT_RECIPE ), \"r\" ) as r : with open ( str ( path ), \"w\" ) as w : w . write ( r . read ()) self . _load ()","title":"ContainerRecipe"},{"location":"rezup/#rezup.recipe.ContainerRecipe.create","text":"Write out recipe content into a .toml file Parameters: Name Type Description Default data dict Arbitrary data to write out None Source code in rezup/recipe.py def create ( self , data = None ): \"\"\"Write out recipe content into a .toml file Args: data (dict, optional): Arbitrary data to write out \"\"\" if not self . RECIPES_DIR . is_dir (): self . RECIPES_DIR . mkdir ( parents = True ) path = self . path () if data : _data = toml . load ( str ( self . DEFAULT_RECIPE )) deep_update ( _data , data ) with open ( str ( path ), \"w\" ) as f : toml . dump ( _data , f ) else : # read & write as plaintext, so the comment can be preserved with open ( str ( self . DEFAULT_RECIPE ), \"r\" ) as r : with open ( str ( path ), \"w\" ) as w : w . write ( r . read ()) self . _load ()","title":"create()"},{"location":"rezup/#rezup.recipe.ContainerRecipe.iter_recipes","text":"Iter all recipe files found in ContainerRecipe.RECIPES_DIR Yields: Type Description ContainerRecipe Source code in rezup/recipe.py @classmethod def iter_recipes ( cls ): \"\"\"Iter all recipe files found in `ContainerRecipe.RECIPES_DIR` Yields: `ContainerRecipe` \"\"\" for item in cls . RECIPES_DIR . iterdir (): if not item . is_file (): continue match = cls . REGEX . search ( item . name ) if match : name = match . group ( 1 ) yield cls ( name )","title":"iter_recipes()"},{"location":"rezup/#rezup.recipe.ContainerRecipe.path","text":"Returns the file path of this recipe Returns: Type Description pathlib.Path The file path of this recipe Source code in rezup/recipe.py def path ( self ): \"\"\"Returns the file path of this recipe Returns: pathlib.Path: The file path of this recipe \"\"\" if self . _path is None : self . _path = self . RECIPES_DIR / self . _file return self . _path","title":"path()"},{"location":"rezup/#rezup.recipe.ContainerRecipe.provisional_recipes","text":"Context for changing recipes root temporarily Container recipes should be in user's home directory by defaule, but that could be changed inside this context for the case when you need to operate on machines that have no recipe exists in home directory. with ContainerRecipe.provisional_recipes(\"/to/other/recipes\"): ... Parameters: Name Type Description Default path str or path-like directory path where recipes located required Source code in rezup/recipe.py @classmethod @contextmanager def provisional_recipes ( cls , path ): \"\"\"Context for changing recipes root temporarily Container recipes should be in user's home directory by defaule, but that could be changed inside this context for the case when you need to operate on machines that have no recipe exists in home directory. ``` with ContainerRecipe.provisional_recipes(\"/to/other/recipes\"): ... ``` Args: path (str or path-like): directory path where recipes located \"\"\" default = cls . RECIPES_DIR try : cls . RECIPES_DIR = Path ( path ) yield finally : cls . RECIPES_DIR = default","title":"provisional_recipes()"},{"location":"rezup/#get_container_root","text":"Internal use Get container root path from recipe # rezup.foo.toml [root] local = \"\" remote = \"/path/to/remote/containers\" If the recipe represents the above example recipe file, container named foo will have local root set to rezup.recipe.DEFAULT_CONTAINER_RECIPES , unless environ variable REZUP_ROOT_LOCAL has value. And the remote root will set to /path/to/remote/containers . Parameters: Name Type Description Default recipe `ContainerRecipe` The container recipe to lookup from. required remote bool Fetch remote root if True, otherwise local. False Returns: Type Description `pathlib.Path` Container root path, local or remote one. Source code in rezup/container.py def get_container_root ( recipe , remote = False ): \"\"\"Get container root path from recipe ```toml # rezup.foo.toml [root] local = \"\" remote = \"/path/to/remote/containers\" ``` If the `recipe` represents the above example recipe file, container named `foo` will have local root set to `rezup.recipe.DEFAULT_CONTAINER_RECIPES`, unless environ variable `REZUP_ROOT_LOCAL` has value. And the remote root will set to `/path/to/remote/containers`. Args: recipe (`ContainerRecipe`): The container recipe to lookup from. remote (bool): Fetch remote root if True, otherwise local. Returns: `pathlib.Path`: Container root path, local or remote one. \"\"\" data = recipe . data () if remote : remote = \\ data [ \"root\" ][ \"remote\" ] \\ or os . getenv ( \"REZUP_ROOT_REMOTE\" ) return Path ( norm_path ( remote )) if remote else None else : local = \\ data [ \"root\" ][ \"local\" ] \\ or os . getenv ( \"REZUP_ROOT_LOCAL\" ) \\ or \"~/.rezup\" return Path ( norm_path ( local ))","title":"get_container_root"},{"location":"rezup/#container","text":"Timestamp ordered virtual environment stack A Rez venv provider, that allows updating venv continuously without affecting any existing consumer. In filesystem, a container is a folder that has at least one Rez venv installation exists, and those Rez venv folders ( Revision ) are named by timestamp, so when the container is being asked for a venv to use, the current latest available one will be sorted out. The location of the container can be set with env var REZUP_ROOT_LOCAL or ~/.rezup will be used by default. For centralize management in production, one remote container can be defined with an env var REZUP_ROOT_REMOTE . The remote container only contains the venv installation manifest file, and when being asked, a venv will be created locally or re-used if same revision exists in local. Parameters: Name Type Description Default name `str` Container name, use Container.DEFAULT_NAME if not given. None recipe `ContainerRecipe` A ContainerRecipe object to help constructing container, will look into ContainerRecipe.RECIPES_DIR if not given. None force_local `bool` Default False . Ignore linking remote even if the remote path has set, always link to local if True . False Source code in rezup/container.py class Container : \"\"\"Timestamp ordered virtual environment stack A Rez venv provider, that allows updating venv continuously without affecting any existing consumer. In filesystem, a container is a folder that has at least one Rez venv installation exists, and those Rez venv folders (`Revision`) are named by timestamp, so when the container is being asked for a venv to use, the current latest available one will be sorted out. The location of the container can be set with env var `REZUP_ROOT_LOCAL` or `~/.rezup` will be used by default. For centralize management in production, one remote container can be defined with an env var `REZUP_ROOT_REMOTE`. The remote container only contains the venv installation manifest file, and when being asked, a venv will be created locally or re-used if same revision exists in local. Args: name (`str`, optional): Container name, use `Container.DEFAULT_NAME` if not given. recipe (`ContainerRecipe`, optional): A `ContainerRecipe` object to help constructing container, will look into `ContainerRecipe.RECIPES_DIR` if not given. force_local (`bool`, optional): Default `False`. Ignore linking remote even if the remote path has set, always link to local if `True`. \"\"\" DEFAULT_NAME = DEFAULT_CONTAINER_NAME #: `rezup.recipe.DEFAULT_CONTAINER_NAME` def __init__ ( self , name = None , recipe = None , force_local = False ): name = name or self . DEFAULT_NAME recipe = recipe or ContainerRecipe ( name ) local_root = get_container_root ( recipe , remote = False ) remote_root = get_container_root ( recipe , remote = True ) if force_local : root = local_root else : root = remote_root or local_root self . _remote = root == remote_root self . _recipe = recipe self . _name = name self . _root = root self . _path = root / name def __repr__ ( self ): return \" %s (remote= %d , name= %r , path= %r )\" % ( self . __class__ . __name__ , int ( self . is_remote ()), self . name (), self . _path . resolve (), ) @classmethod def create ( cls , name , force_local = False ): \"\"\"Create container from recipe. Args: name (str): The name of container. force_local (bool): Create as local if True, or try remote. Returns: `Container`: A container instance. \"\"\" recipe = ContainerRecipe ( name ) _log . debug ( \"Sourcing recipe from: %s \" % recipe ) if not recipe . is_file (): _log . debug ( \"Recipe file not exists, creating default..\" ) recipe . create () return Container ( name , recipe , force_local ) def root ( self ): \"\"\" Returns: `pathlib.Path`: Path to where this container is located. \"\"\" return self . _root def name ( self ): \"\"\" Returns: str: Container name. \"\"\" return self . _name def path ( self ): \"\"\" Returns: `pathlib.Path`: Full path of this container. \"\"\" return self . _path def recipe ( self ): \"\"\" Returns: `ContainerRecipe`: The recipe instance that binds to this container. \"\"\" return self . _recipe def libs ( self ): \"\"\" Returns: `pathlib.Path`: Path to this container's shared libraries. \"\"\" return self . _path / \"libs\" def revisions ( self ): \"\"\" Returns: `pathlib.Path`: Path to this container's revisions. \"\"\" return self . _path / \"revisions\" def is_exists ( self ): \"\"\" Returns: bool: Return `True` if this container exists. \"\"\" return self . _path . is_dir () def is_empty ( self ): \"\"\" Returns: bool: Return `True` if this container has no valid revisions. \"\"\" return not bool ( next ( self . iter_revision (), None )) def is_remote ( self ): \"\"\" Returns: bool: Return `True` if this container is linked to remote side. \"\"\" return self . _remote def purge ( self ): if self . is_exists (): revision = self . get_latest_revision ( only_ready = False ) if not revision : # TODO: don't remove it immediately, mark as purged and # remove it when $REZUP_CLEAN_AFTER meet rmtree ( self . _path ) else : # TODO: should have better exception type # TODO: need to check revision is in use raise Exception ( \"Revision is creating.\" ) # keep tidy, try remove the root of containers if it's now empty root = self . root () if root . is_dir () and not next ( root . iterdir (), None ): rmtree ( root ) def iter_revision ( self , validate = True , latest_first = True ): \"\"\"Iterating revisions from this container. Args: validate (bool, optional): Default `True`. Only yield revisions that are valid if `True`. latest_first (bool): Default `True`. Yield revisions based on it's directory name (timestamp string) in descending order, or ascending if `False`. Yields: Revision: `Revision` instances that match the condition. \"\"\" _log . debug ( \"Iterating revisions in container %s ..\" % self ) if not self . is_exists (): _log . debug ( \"Container %r not exists.\" % self . name ()) return revisions_root = Revision . compose_path ( container = self ) if not revisions_root . is_dir (): _log . debug ( \"Revision root is not a directory: %s \" % revisions_root ) return revisions_root = str ( revisions_root ) for entry in sorted ( os . listdir ( revisions_root ), reverse = latest_first ): revision = Revision ( container = self , dirname = entry ) _log . debug ( \"... %s \" % revision ) if not validate or revision . is_valid (): yield revision def get_latest_revision ( self , only_ready = True ): \"\"\"Get latest revision from this container. Args: only_ready (bool): Default `True`. Include revisions that are not in ready state if `False`. Returns: Revision: An instance of `Revision` if found, or `None`. \"\"\" for revision in self . iter_revision (): if not only_ready or revision . is_ready (): _log . debug ( \"Found latest revision.\" ) return revision def get_revision_by_time ( self , timestamp , fallback = False , only_ready = True ): \"\"\"Returns a revision that match the timestamp Args: timestamp (datetime.datetime): a time for matching revision fallback (bool): If True, accept earlier revision when no exact matched only_ready (bool): Include revisions that are not in ready state if False Returns: Revision: An instance of `Revision` if found, or `None`. \"\"\" for revision in self . iter_revision (): if not only_ready or revision . is_ready (): if ( revision . timestamp () == timestamp or ( fallback and revision . timestamp () <= timestamp )): _log . debug ( \"Found time matched revision.\" ) return revision _log . debug ( \"No time matched revision found.\" ) def new_revision ( self ): \"\"\"Create a new revision Returns: Revision: An instance of `Revision` that just created. \"\"\" return Revision . create ( self )","title":"Container"},{"location":"rezup/#rezup.container.Container.create","text":"Create container from recipe. Parameters: Name Type Description Default name str The name of container. required force_local bool Create as local if True, or try remote. False Returns: Type Description `Container` A container instance. Source code in rezup/container.py @classmethod def create ( cls , name , force_local = False ): \"\"\"Create container from recipe. Args: name (str): The name of container. force_local (bool): Create as local if True, or try remote. Returns: `Container`: A container instance. \"\"\" recipe = ContainerRecipe ( name ) _log . debug ( \"Sourcing recipe from: %s \" % recipe ) if not recipe . is_file (): _log . debug ( \"Recipe file not exists, creating default..\" ) recipe . create () return Container ( name , recipe , force_local )","title":"create()"},{"location":"rezup/#rezup.container.Container.get_latest_revision","text":"Get latest revision from this container. Parameters: Name Type Description Default only_ready bool Default True . Include revisions that are not in ready state if False . True Returns: Type Description Revision An instance of Revision if found, or None . Source code in rezup/container.py def get_latest_revision ( self , only_ready = True ): \"\"\"Get latest revision from this container. Args: only_ready (bool): Default `True`. Include revisions that are not in ready state if `False`. Returns: Revision: An instance of `Revision` if found, or `None`. \"\"\" for revision in self . iter_revision (): if not only_ready or revision . is_ready (): _log . debug ( \"Found latest revision.\" ) return revision","title":"get_latest_revision()"},{"location":"rezup/#rezup.container.Container.get_revision_by_time","text":"Returns a revision that match the timestamp Parameters: Name Type Description Default timestamp datetime.datetime a time for matching revision required fallback bool If True, accept earlier revision when no exact matched False only_ready bool Include revisions that are not in ready state if False True Returns: Type Description Revision An instance of Revision if found, or None . Source code in rezup/container.py def get_revision_by_time ( self , timestamp , fallback = False , only_ready = True ): \"\"\"Returns a revision that match the timestamp Args: timestamp (datetime.datetime): a time for matching revision fallback (bool): If True, accept earlier revision when no exact matched only_ready (bool): Include revisions that are not in ready state if False Returns: Revision: An instance of `Revision` if found, or `None`. \"\"\" for revision in self . iter_revision (): if not only_ready or revision . is_ready (): if ( revision . timestamp () == timestamp or ( fallback and revision . timestamp () <= timestamp )): _log . debug ( \"Found time matched revision.\" ) return revision _log . debug ( \"No time matched revision found.\" )","title":"get_revision_by_time()"},{"location":"rezup/#rezup.container.Container.is_empty","text":"Returns: Type Description bool Return True if this container has no valid revisions. Source code in rezup/container.py def is_empty ( self ): \"\"\" Returns: bool: Return `True` if this container has no valid revisions. \"\"\" return not bool ( next ( self . iter_revision (), None ))","title":"is_empty()"},{"location":"rezup/#rezup.container.Container.is_exists","text":"Returns: Type Description bool Return True if this container exists. Source code in rezup/container.py def is_exists ( self ): \"\"\" Returns: bool: Return `True` if this container exists. \"\"\" return self . _path . is_dir ()","title":"is_exists()"},{"location":"rezup/#rezup.container.Container.is_remote","text":"Returns: Type Description bool Return True if this container is linked to remote side. Source code in rezup/container.py def is_remote ( self ): \"\"\" Returns: bool: Return `True` if this container is linked to remote side. \"\"\" return self . _remote","title":"is_remote()"},{"location":"rezup/#rezup.container.Container.iter_revision","text":"Iterating revisions from this container. Parameters: Name Type Description Default validate bool Default True . Only yield revisions that are valid if True . True latest_first bool Default True . Yield revisions based on it's directory name (timestamp string) in descending order, or ascending if False . True Yields: Type Description Revision Revision instances that match the condition. Source code in rezup/container.py def iter_revision ( self , validate = True , latest_first = True ): \"\"\"Iterating revisions from this container. Args: validate (bool, optional): Default `True`. Only yield revisions that are valid if `True`. latest_first (bool): Default `True`. Yield revisions based on it's directory name (timestamp string) in descending order, or ascending if `False`. Yields: Revision: `Revision` instances that match the condition. \"\"\" _log . debug ( \"Iterating revisions in container %s ..\" % self ) if not self . is_exists (): _log . debug ( \"Container %r not exists.\" % self . name ()) return revisions_root = Revision . compose_path ( container = self ) if not revisions_root . is_dir (): _log . debug ( \"Revision root is not a directory: %s \" % revisions_root ) return revisions_root = str ( revisions_root ) for entry in sorted ( os . listdir ( revisions_root ), reverse = latest_first ): revision = Revision ( container = self , dirname = entry ) _log . debug ( \"... %s \" % revision ) if not validate or revision . is_valid (): yield revision","title":"iter_revision()"},{"location":"rezup/#rezup.container.Container.libs","text":"Returns: Type Description `pathlib.Path` Path to this container's shared libraries. Source code in rezup/container.py def libs ( self ): \"\"\" Returns: `pathlib.Path`: Path to this container's shared libraries. \"\"\" return self . _path / \"libs\"","title":"libs()"},{"location":"rezup/#rezup.container.Container.name","text":"Returns: Type Description str Container name. Source code in rezup/container.py def name ( self ): \"\"\" Returns: str: Container name. \"\"\" return self . _name","title":"name()"},{"location":"rezup/#rezup.container.Container.new_revision","text":"Create a new revision Returns: Type Description Revision An instance of Revision that just created. Source code in rezup/container.py def new_revision ( self ): \"\"\"Create a new revision Returns: Revision: An instance of `Revision` that just created. \"\"\" return Revision . create ( self )","title":"new_revision()"},{"location":"rezup/#rezup.container.Container.path","text":"Returns: Type Description `pathlib.Path` Full path of this container. Source code in rezup/container.py def path ( self ): \"\"\" Returns: `pathlib.Path`: Full path of this container. \"\"\" return self . _path","title":"path()"},{"location":"rezup/#rezup.container.Container.recipe","text":"Returns: Type Description `ContainerRecipe` The recipe instance that binds to this container. Source code in rezup/container.py def recipe ( self ): \"\"\" Returns: `ContainerRecipe`: The recipe instance that binds to this container. \"\"\" return self . _recipe","title":"recipe()"},{"location":"rezup/#rezup.container.Container.revisions","text":"Returns: Type Description `pathlib.Path` Path to this container's revisions. Source code in rezup/container.py def revisions ( self ): \"\"\" Returns: `pathlib.Path`: Path to this container's revisions. \"\"\" return self . _path / \"revisions\"","title":"revisions()"},{"location":"rezup/#rezup.container.Container.root","text":"Returns: Type Description `pathlib.Path` Path to where this container is located. Source code in rezup/container.py def root ( self ): \"\"\" Returns: `pathlib.Path`: Path to where this container is located. \"\"\" return self . _root","title":"root()"},{"location":"rezup/#revision","text":"Parameters: Name Type Description Default container Container The container that holds this revision required dirname str Directory name of this revision, should be a timestamp string if given. None Source code in rezup/container.py class Revision : \"\"\" Args: container (Container): The container that holds this revision dirname (str, optional): Directory name of this revision, should be a timestamp string if given. \"\"\" def __init__ ( self , container , dirname = None ): dirname = str ( dirname or time . time ()) self . _container = container self . _dirname = dirname self . _path = self . compose_path ( container , dirname ) self . _timestamp = None self . _is_valid = None self . _metadata = None self . _recipe = RevisionRecipe ( self ) self . _metadata_path = self . _path / \"revision.json\" self . _is_pulled = False def __repr__ ( self ): return \" %s (valid= %d , ready= %d , remote= %d , time= %s , path= %r )\" % ( self . __class__ . __name__ , int ( self . is_valid ()), int ( self . is_ready ()), int ( self . is_remote ()), self . time_str () or \"?\" , self . _path . resolve (), ) def __eq__ ( self , other ): if not isinstance ( other , type ( self )): return False return self . _container . name () == other . _container . name () \\ and self . timestamp () == other . timestamp () @classmethod def compose_path ( cls , container , dirname = None ): path = container . revisions () if dirname : path /= dirname return path @classmethod def create ( cls , container ): revision = cls ( container = container ) revision . _write () return revision def _write ( self , pulling = None ): \"\"\"Sourcing recipe and create a revision Args: pulling (Revision, optional): If given, pulling recipe from that revision, usually a remote one. \"\"\" _log . info ( \"Creating revision..\" ) recipe = self . _recipe makedirs ( self . _path ) # write revision recipe if pulling is None : _log . info ( \"Recipe sourced from: %s \" % self . _container . recipe ()) recipe . create () else : _log . debug ( \"Pulling recipe from: %s \" % pulling ) recipe . pull ( pulling ) if not self . is_valid (): raise Exception ( \"Invalid new revision, this is a bug.\" ) # manifest rez_ = Tool ( recipe [ \"rez\" ]) extensions = [ Tool ( d ) for d in recipe . get ( \"extension\" , []) if d ] shared_lib = recipe . get ( \"shared\" ) _log . info ( \"Recipe loaded.\" ) _log . debug ( \" Rez: %s \" % rez_ . url ) _log . debug ( \" Extension: \" + \", \" . join ([ e . name for e in extensions ])) _log . debug ( \"Shared-lib: %s \" % shared_lib ) # install, if at local if not self . _container . is_remote (): self . _install ( rez_ , extensions , shared_lib ) # save metadata, mark revision as ready with open ( str ( self . _metadata_path ), \"w\" ) as f : # metadata f . write ( json . dumps ({ \"rezup_version\" : __version__ , \"creator\" : getpass . getuser (), \"hostname\" : socket . gethostname (), \"revision_path\" : str ( self . _path ), \"venvs\" : [ \"rez\" ] + [ t . name for t in extensions if t . isolation ], }, indent = 4 )) _log . info ( \"Revision created: %s \" % self ) def _install ( self , rez_ , extensions = None , shared_lib = None ): \"\"\"Construct Rez virtual environment by recipe \"\"\" _log . debug ( \"Installing..\" ) pip_entry = self . _recipe . get ( \"pip\" ) extensions = extensions or [] installer = Installer ( self , pip_opt = pip_entry . get ( \"options\" ), pip_env = pip_entry . get ( \"env\" ), ) installer . install_rez ( rez_ ) if shared_lib : warnings . warn ( \"Shared-lib section is about to be deprecated, \" \"use 'rez.lib' or 'extension.lib' section instead. \" \"See https://github.com/davidlatwe/rezup/issues/62\" , DeprecationWarning ) installer . create_shared_lib ( name = shared_lib [ \"name\" ], requires = shared_lib [ \"requires\" ]) for ext in extensions : installer . install_extension ( ext ) def validate ( self ): is_valid = True seconds = float ( self . _dirname ) timestamp = datetime . fromtimestamp ( seconds ) if self . _recipe . is_file (): self . _timestamp = timestamp else : is_valid = False return is_valid def is_valid ( self ): if self . _is_valid is None : try : self . _is_valid = self . validate () except ( OSError , ValueError ): self . _is_valid = False return self . _is_valid def is_ready ( self ): return self . _metadata_path . is_file () def is_remote ( self ): return self . _container . is_remote () def dirname ( self ): return self . _dirname def path ( self ): return self . _path def timestamp ( self ): return self . _timestamp def time_str ( self ): return self . _timestamp . strftime ( \" %d .%b.%y %H:%M\" ) \\ if self . _timestamp else \"\" def container ( self ): return self . _container def metadata ( self ): if self . is_ready (): if self . _metadata is None : with open ( str ( self . _metadata_path ), \"r\" ) as f : self . _metadata = json . load ( f ) return self . _metadata def recipe ( self ): if self . is_valid (): return self . _recipe def recipe_env ( self ): _platform = platform . system () . lower () recipe = self . recipe () or {} env = {} def load_env ( ** kwargs ): return { k : v for k , v in dotenv_values ( ** kwargs ) . items () if v is not None # exclude config section line } def file_loader ( d ): return [ d [ k ] for k in sorted ([ k for k , v in d . items () if isinstance ( v , string_types )])] dot_env = recipe . get ( \"dotenv\" ) if dot_env : # non platform specific dotenv env_files = file_loader ( dot_env ) if isinstance ( dot_env . get ( _platform ), dict ): # platform specific dotenv env_files += file_loader ( dot_env [ _platform ]) for file in env_files : env . update ( load_env ( dotenv_path = file )) recipe_env = recipe . get ( \"env\" ) if recipe_env : stream = StringIO () _parser = ConfigParser () _parser . optionxform = str # to prevent turning keys into lowercase _parser . read_dict ({ \"env\" : recipe_env }) _parser . write ( stream ) stream . seek ( 0 ) # must reset buffer env . update ( load_env ( stream = stream )) env . update ({ \"REZUP_CONTAINER\" : self . _container . name (), \"REZUP_USING_REMOTE\" : \"yes\" if self . _is_pulled else \"\" , }) return env def purge ( self ): if self . is_valid (): # TODO: don't remove it immediately, mark as purged and # remove it when $REZUP_CLEAN_AFTER meet rmtree ( self . _path ) def iter_backward ( self ): for revision in self . _container . iter_revision ( latest_first = True ): if revision . timestamp () < self . _timestamp : yield revision def iter_forward ( self ): for revision in self . _container . iter_revision ( latest_first = False ): if revision . timestamp () > self . _timestamp : yield revision def pull ( self , check_out = True , fallback = False ): \"\"\"Return corresponding local side revision If the revision is from remote container, calling this method will find a timestamp matched local revision and create one if not found by default. If the revision is from local container, return `self`. Args: check_out (bool, optional): When no matched local revision, create one if True or just return None at the end. Default is True. fallback (bool, optional) Returns: Revision or None \"\"\" if not self . is_remote (): return self # get local _con_name = self . _container . name () _con_recipe = self . _container . recipe () # careful, this affect's root local = Container ( _con_name , recipe = _con_recipe , force_local = True ) rev = local . get_revision_by_time ( self . _timestamp , fallback = fallback , only_ready = True ) _allow_create = rev is None and check_out _did_fallback = rev . timestamp () != self . _timestamp if rev else False if not fallback and _allow_create : _log . info ( \"Pulling from remote container: %s \" % self . _container ) rev = Revision ( container = local , dirname = self . _dirname ) rev . _write ( pulling = self ) if fallback and _did_fallback : _log . warning ( \"Local revision at exact time ( %s ) is not ready, \" \"fallback to %s \" % ( self . time_str (), rev ) ) if rev is not None : rev . _is_pulled = True return rev def spawn_shell ( self , command = None ): \"\"\"Spawn a sub-shell Args: command (list, optional): Shell script file with args or commands. If given, the sub-shell will not be interactive. Returns: subprocess.Popen Raises: ContainerError \"\"\" if not self . is_valid (): raise ContainerError ( \"Cannot use invalid revision.\" ) if not self . is_ready (): raise ContainerError ( \"Revision is not ready to be used.\" ) if self . is_remote (): # use local revision = self . pull () if revision is None : raise ContainerError ( \"No revision pulled.\" ) if not revision . is_ready (): raise ContainerError ( \"Revision is not ready to be used.\" ) return revision . spawn_shell ( command = command ) else : # Launch subprocess environment = self . _compose_env () shell_name , shell_exec = self . _get_shell () if command : # run command and exit if command [ 0 ] == \".\" : cmd = command else : exe = command [ 0 ] exe = shell . which ( exe , env = environment ) or exe cmd = [ exe ] + command [ 1 :] else : # interactive shell _con_name = self . _container . name () _con_from = \"remote\" if self . _is_pulled else \"local\" prompt = \"rezup ( %s / %s ) \" % ( _con_name , _con_from ) prompt = shell . format_prompt_code ( prompt , shell_name ) environment . update ({ \"REZUP_PROMPT\" : os . getenv ( \"REZUP_PROMPT\" , prompt ), }) cmd = shell . get_launch_cmd ( shell_name , shell_exec , interactive = True , ) popen = subprocess . Popen ( cmd , env = environment ) return popen def use ( self , command = None , wait = True ): \"\"\"Run a sub-shell Args: command (list, optional): Shell script with args or commands. If given, the sub-shell will not be interactive. wait (bool, optional): Whether to wait `command` finish or not, default True. Returns: int: subprocess return code, will always return 0 if `command` is given and `wait` is False. \"\"\" block = not command popen = self . spawn_shell ( command = command ) if block or wait : stdout , stderr = popen . communicate () return popen . returncode else : return 0 def _compose_env ( self ): env = os . environ . copy () env . update ( self . recipe_env () or {}) env [ \"PATH\" ] = os . pathsep . join ([ os . pathsep . join ([ str ( p ) for p in self . production_bin_dirs ()]), env [ \"PATH\" ] ]) # use `pythonfinder` package if need to exclude python from PATH return env def _get_shell ( self ): shell_name = os . getenv ( \"REZUP_DEFAULT_SHELL\" ) if shell_name : shell_exec = shell_name shell_name , ext = os . path . splitext ( os . path . basename ( shell_name )) shell_name = shell_name . lower () else : shell_name , shell_exec = shell . get_current_shell () shell_exec = shell_exec or shell_name return shell_name , shell_exec def _require_local ( method ): # noqa \"\"\"Decorator for ensuring local revision exists before action \"\"\" @functools . wraps ( method ) # noqa def wrapper ( self , * args , ** kwargs ): if not self . is_remote (): return method ( self , * args , ** kwargs ) # noqa check_out = bool ( os . getenv ( \"REZUP_ALWAYS_CHECKOUT\" )) revision = self . pull ( check_out = check_out ) if revision is None : raise ContainerError ( \"This revision is from remote container, no matched found \" \"in local. Possible not been pulled into local yet.\" ) return getattr ( revision , method . __name__ )( self , * args , ** kwargs ) return wrapper @_require_local # noqa def locate_rez_lib ( self , venv_session = None ): \"\"\"Returns rez module location in this revision Returns: pathlib.Path or None if not found. \"\"\" if venv_session is None : venv_path = self . path () / \"venv\" / \"rez\" venv_session = virtualenv . session_via_cli ( args = [ str ( venv_path )]) venv_lib = venv_session . creator . purelib # rez may get installed in edit mode, try short route first egg_link = venv_lib / \"rez.egg-link\" if egg_link . is_file (): with open ( str ( egg_link ), \"r\" ) as f : package_location = f . readline () . strip () if os . path . isdir ( package_location ): return Path ( package_location ) for importer , modname , pkg in pkgutil . walk_packages ([ str ( venv_lib )]): if pkg and modname == \"rez\" : loader = importer . find_module ( modname ) try : path = loader . path # SourceFileLoader return Path ( path ) . parent . parent except AttributeError : path = loader . filename # ImpLoader, py2 return Path ( path ) . parent @_require_local # noqa def get_rez_version ( self , venv_session = None ): \"\"\"Returns rez version installed in this revision Returns: str or None if not found. \"\"\" rez_location = self . locate_rez_lib ( venv_session ) if rez_location is None : return version_py = rez_location / \"rez\" / \"utils\" / \"_version.py\" if version_py . is_file (): _locals = { \"_rez_version\" : \"\" } with open ( str ( version_py )) as f : exec ( f . read (), globals (), _locals ) return _locals [ \"_rez_version\" ] @_require_local # noqa def production_bin_dir ( self , venv_name ): \"\"\"Returns production bin scripts dir in this revision Returns: pathlib.Path, but the directory may not exists. \"\"\" bin_dirname = \"Scripts\" if platform . system () == \"Windows\" else \"bin\" venv_bin_dir = self . path () / \"venv\" / venv_name / bin_dirname return venv_bin_dir / \"rez\" @_require_local # noqa def production_bin_dirs ( self ): bin_dirs = [] metadata = self . metadata () if metadata and not metadata . get ( \"rezup_version\" ): # rezup-1.x _log . debug ( \"Is a 'rezup-1.x' styled revision.\" ) bin_dirs . append ( self . _path / \"bin\" ) else : # rezup-2.x _log . debug ( \"Is a 'rezup-2.x' styled revision.\" ) for venv_name in metadata . get ( \"venvs\" , []): bin_dirs . append ( self . production_bin_dir ( venv_name )) return bin_dirs","title":"Revision"},{"location":"rezup/#rezup.container.Revision.get_rez_version","text":"Returns rez version installed in this revision Returns: Type Description str or None if not found. Source code in rezup/container.py @_require_local # noqa def get_rez_version ( self , venv_session = None ): \"\"\"Returns rez version installed in this revision Returns: str or None if not found. \"\"\" rez_location = self . locate_rez_lib ( venv_session ) if rez_location is None : return version_py = rez_location / \"rez\" / \"utils\" / \"_version.py\" if version_py . is_file (): _locals = { \"_rez_version\" : \"\" } with open ( str ( version_py )) as f : exec ( f . read (), globals (), _locals ) return _locals [ \"_rez_version\" ]","title":"get_rez_version()"},{"location":"rezup/#rezup.container.Revision.locate_rez_lib","text":"Returns rez module location in this revision Returns: Type Description pathlib.Path or None if not found. Source code in rezup/container.py @_require_local # noqa def locate_rez_lib ( self , venv_session = None ): \"\"\"Returns rez module location in this revision Returns: pathlib.Path or None if not found. \"\"\" if venv_session is None : venv_path = self . path () / \"venv\" / \"rez\" venv_session = virtualenv . session_via_cli ( args = [ str ( venv_path )]) venv_lib = venv_session . creator . purelib # rez may get installed in edit mode, try short route first egg_link = venv_lib / \"rez.egg-link\" if egg_link . is_file (): with open ( str ( egg_link ), \"r\" ) as f : package_location = f . readline () . strip () if os . path . isdir ( package_location ): return Path ( package_location ) for importer , modname , pkg in pkgutil . walk_packages ([ str ( venv_lib )]): if pkg and modname == \"rez\" : loader = importer . find_module ( modname ) try : path = loader . path # SourceFileLoader return Path ( path ) . parent . parent except AttributeError : path = loader . filename # ImpLoader, py2 return Path ( path ) . parent","title":"locate_rez_lib()"},{"location":"rezup/#rezup.container.Revision.production_bin_dir","text":"Returns production bin scripts dir in this revision Returns: Type Description pathlib.Path, but the directory may not exists. Source code in rezup/container.py @_require_local # noqa def production_bin_dir ( self , venv_name ): \"\"\"Returns production bin scripts dir in this revision Returns: pathlib.Path, but the directory may not exists. \"\"\" bin_dirname = \"Scripts\" if platform . system () == \"Windows\" else \"bin\" venv_bin_dir = self . path () / \"venv\" / venv_name / bin_dirname return venv_bin_dir / \"rez\"","title":"production_bin_dir()"},{"location":"rezup/#rezup.container.Revision.pull","text":"Return corresponding local side revision If the revision is from remote container, calling this method will find a timestamp matched local revision and create one if not found by default. If the revision is from local container, return self . Parameters: Name Type Description Default check_out bool When no matched local revision, create one if True or just return None at the end. Default is True. True Returns: Type Description Revision or None Source code in rezup/container.py def pull ( self , check_out = True , fallback = False ): \"\"\"Return corresponding local side revision If the revision is from remote container, calling this method will find a timestamp matched local revision and create one if not found by default. If the revision is from local container, return `self`. Args: check_out (bool, optional): When no matched local revision, create one if True or just return None at the end. Default is True. fallback (bool, optional) Returns: Revision or None \"\"\" if not self . is_remote (): return self # get local _con_name = self . _container . name () _con_recipe = self . _container . recipe () # careful, this affect's root local = Container ( _con_name , recipe = _con_recipe , force_local = True ) rev = local . get_revision_by_time ( self . _timestamp , fallback = fallback , only_ready = True ) _allow_create = rev is None and check_out _did_fallback = rev . timestamp () != self . _timestamp if rev else False if not fallback and _allow_create : _log . info ( \"Pulling from remote container: %s \" % self . _container ) rev = Revision ( container = local , dirname = self . _dirname ) rev . _write ( pulling = self ) if fallback and _did_fallback : _log . warning ( \"Local revision at exact time ( %s ) is not ready, \" \"fallback to %s \" % ( self . time_str (), rev ) ) if rev is not None : rev . _is_pulled = True return rev","title":"pull()"},{"location":"rezup/#rezup.container.Revision.spawn_shell","text":"Spawn a sub-shell Parameters: Name Type Description Default command list Shell script file with args or commands. If given, the sub-shell will not be interactive. None Returns: Type Description subprocess.Popen Source code in rezup/container.py def spawn_shell ( self , command = None ): \"\"\"Spawn a sub-shell Args: command (list, optional): Shell script file with args or commands. If given, the sub-shell will not be interactive. Returns: subprocess.Popen Raises: ContainerError \"\"\" if not self . is_valid (): raise ContainerError ( \"Cannot use invalid revision.\" ) if not self . is_ready (): raise ContainerError ( \"Revision is not ready to be used.\" ) if self . is_remote (): # use local revision = self . pull () if revision is None : raise ContainerError ( \"No revision pulled.\" ) if not revision . is_ready (): raise ContainerError ( \"Revision is not ready to be used.\" ) return revision . spawn_shell ( command = command ) else : # Launch subprocess environment = self . _compose_env () shell_name , shell_exec = self . _get_shell () if command : # run command and exit if command [ 0 ] == \".\" : cmd = command else : exe = command [ 0 ] exe = shell . which ( exe , env = environment ) or exe cmd = [ exe ] + command [ 1 :] else : # interactive shell _con_name = self . _container . name () _con_from = \"remote\" if self . _is_pulled else \"local\" prompt = \"rezup ( %s / %s ) \" % ( _con_name , _con_from ) prompt = shell . format_prompt_code ( prompt , shell_name ) environment . update ({ \"REZUP_PROMPT\" : os . getenv ( \"REZUP_PROMPT\" , prompt ), }) cmd = shell . get_launch_cmd ( shell_name , shell_exec , interactive = True , ) popen = subprocess . Popen ( cmd , env = environment ) return popen","title":"spawn_shell()"},{"location":"rezup/#rezup.container.Revision.use","text":"Run a sub-shell Parameters: Name Type Description Default command list Shell script with args or commands. If given, the sub-shell will not be interactive. None wait bool Whether to wait command finish or not, default True. True Returns: Type Description int subprocess return code, will always return 0 if command is given and wait is False. Source code in rezup/container.py def use ( self , command = None , wait = True ): \"\"\"Run a sub-shell Args: command (list, optional): Shell script with args or commands. If given, the sub-shell will not be interactive. wait (bool, optional): Whether to wait `command` finish or not, default True. Returns: int: subprocess return code, will always return 0 if `command` is given and `wait` is False. \"\"\" block = not command popen = self . spawn_shell ( command = command ) if block or wait : stdout , stderr = popen . communicate () return popen . returncode else : return 0","title":"use()"},{"location":"rezup/#containererror","text":"Any error that related to the container Source code in rezup/exceptions.py class ContainerError ( Exception ): \"\"\"Any error that related to the container\"\"\" pass","title":"ContainerError"},{"location":"rezup.util/","text":"get_revision ( container = None , create = False , fallback = True ) Returns a revision instance from container Parameters: Name Type Description Default container Container name, use default container if name not given. None create Create local revision if not exists, default False. False fallback If True, accept earlier revision when no timestamp matched found in local. True Returns: Type Description Revision An instance of Revision Source code in rezup/util.py def get_revision ( container = None , create = False , fallback = True ): \"\"\"Returns a revision instance from container Args: container: Container name, use default container if name not given. create: Create local revision if not exists, default False. fallback: If True, accept earlier revision when no timestamp matched found in local. Returns: Revision: An instance of Revision Raises: ContainerError \"\"\" name = container or Container . DEFAULT_NAME container = Container ( name ) revision = container . get_latest_revision () if revision is None : if container . is_remote () or not create : raise ContainerError ( \"No valid revision in container %r : %s \" % ( container . name (), container . path ())) else : revision = container . new_revision () revision = revision . pull ( check_out = create , fallback = fallback ) if revision is None : raise ContainerError ( \"No matched revision in local container.\" ) return revision resolve_environ ( revision , requests_or_rxt ) Resolve package requests with Rez from container Open a subprocess and call rez-python that is located from container to resolve the request and returns the context environment. Parameters: Name Type Description Default revision A revision instance that is ready to use required requests_or_rxt List of strings or list of PackageRequest objects, or, a resolved context RXT file. required Returns: Type Description dict The environment dict generated by the resolved context. Exceptions: Type Description ContainerError when no valid revision to use. Source code in rezup/util.py def resolve_environ ( revision , requests_or_rxt ): \"\"\"Resolve package requests with Rez from container Open a subprocess and call rez-python that is located from container to resolve the request and returns the context environment. Args: revision: A revision instance that is ready to use requests_or_rxt: List of strings or list of PackageRequest objects, or, a resolved context RXT file. Returns: dict: The environment dict generated by the resolved context. Raises: ContainerError: when no valid revision to use. subprocess.CalledProcessError \"\"\" if not revision . is_ready (): raise ContainerError ( \"Revision is not ready to be used.\" ) env = os . environ . copy () env . update ( revision . recipe_env () or {}) ext = \".exe\" if sys . platform == \"win32\" else \"\" rez_python = None for bin_dir in revision . production_bin_dirs (): _exec = str ( bin_dir / ( \"rez-python\" + ext )) if os . access ( _exec , os . X_OK ): rez_python = _exec break if rez_python is None : raise ContainerError ( \"rez-python not found in revision: %s \" % revision . path ()) if isinstance ( requests_or_rxt , list ): requests_or_rxt = \" \" . join ([ str ( r ) for r in requests_or_rxt ]) action_py = os . path . join ( os . path . dirname ( __file__ ), \"_actions.py\" ) args = [ rez_python , \"-B\" , # just to be safe, no .pyc ('bad magic number in .pyc' error) action_py , _message_wrap , \"action_resolve\" , # resolve and return serialized context env str ( requests_or_rxt ), ] try : out = subprocess . check_output ( args , env = env , stderr = subprocess . STDOUT , universal_newlines = True , ) except subprocess . CalledProcessError as e : _log . error ( e . output ) raise return json . loads ( polish ( out ))","title":"rezup.util"},{"location":"rezup.util/#_1","text":"","title":""},{"location":"rezup.util/#rezup.util.get_revision","text":"Returns a revision instance from container Parameters: Name Type Description Default container Container name, use default container if name not given. None create Create local revision if not exists, default False. False fallback If True, accept earlier revision when no timestamp matched found in local. True Returns: Type Description Revision An instance of Revision Source code in rezup/util.py def get_revision ( container = None , create = False , fallback = True ): \"\"\"Returns a revision instance from container Args: container: Container name, use default container if name not given. create: Create local revision if not exists, default False. fallback: If True, accept earlier revision when no timestamp matched found in local. Returns: Revision: An instance of Revision Raises: ContainerError \"\"\" name = container or Container . DEFAULT_NAME container = Container ( name ) revision = container . get_latest_revision () if revision is None : if container . is_remote () or not create : raise ContainerError ( \"No valid revision in container %r : %s \" % ( container . name (), container . path ())) else : revision = container . new_revision () revision = revision . pull ( check_out = create , fallback = fallback ) if revision is None : raise ContainerError ( \"No matched revision in local container.\" ) return revision","title":"get_revision()"},{"location":"rezup.util/#rezup.util.resolve_environ","text":"Resolve package requests with Rez from container Open a subprocess and call rez-python that is located from container to resolve the request and returns the context environment. Parameters: Name Type Description Default revision A revision instance that is ready to use required requests_or_rxt List of strings or list of PackageRequest objects, or, a resolved context RXT file. required Returns: Type Description dict The environment dict generated by the resolved context. Exceptions: Type Description ContainerError when no valid revision to use. Source code in rezup/util.py def resolve_environ ( revision , requests_or_rxt ): \"\"\"Resolve package requests with Rez from container Open a subprocess and call rez-python that is located from container to resolve the request and returns the context environment. Args: revision: A revision instance that is ready to use requests_or_rxt: List of strings or list of PackageRequest objects, or, a resolved context RXT file. Returns: dict: The environment dict generated by the resolved context. Raises: ContainerError: when no valid revision to use. subprocess.CalledProcessError \"\"\" if not revision . is_ready (): raise ContainerError ( \"Revision is not ready to be used.\" ) env = os . environ . copy () env . update ( revision . recipe_env () or {}) ext = \".exe\" if sys . platform == \"win32\" else \"\" rez_python = None for bin_dir in revision . production_bin_dirs (): _exec = str ( bin_dir / ( \"rez-python\" + ext )) if os . access ( _exec , os . X_OK ): rez_python = _exec break if rez_python is None : raise ContainerError ( \"rez-python not found in revision: %s \" % revision . path ()) if isinstance ( requests_or_rxt , list ): requests_or_rxt = \" \" . join ([ str ( r ) for r in requests_or_rxt ]) action_py = os . path . join ( os . path . dirname ( __file__ ), \"_actions.py\" ) args = [ rez_python , \"-B\" , # just to be safe, no .pyc ('bad magic number in .pyc' error) action_py , _message_wrap , \"action_resolve\" , # resolve and return serialized context env str ( requests_or_rxt ), ] try : out = subprocess . check_output ( args , env = env , stderr = subprocess . STDOUT , universal_newlines = True , ) except subprocess . CalledProcessError as e : _log . error ( e . output ) raise return json . loads ( polish ( out ))","title":"resolve_environ()"},{"location":"rezup.util_env/","text":"Container environ one-line injector Examples: from rezup.util_env import dot_main # the environ of container '.main' has been applied onto `os.environ` ... # import other stuff With this module, we could inject container environ at the top of script with import statement in one line, instead of something like this: from rezup.util import get_revision os . environ . update ( get_revision ( \".main\" ) . recipe_env ()) ... # import other stuff Which makes linter unhappy. However, Python 3.7+ Required The feature this module provides is based on PEP-562 , which requires Python 3.7+ to work. __dir__() Listing all container as valid importable attribute name Examples: >>> from rezup import util_env >>> dir ( util_env ) [ 'dev' , 'dot_main' ] Source code in rezup/util_env.py def __dir__ (): \"\"\"Listing all container as valid importable attribute name Example: >>> from rezup import util_env >>> dir(util_env) ['dev', 'dot_main'] \"\"\" return [ \"dot_main\" if name == \".main\" else name for name in [ con . name () for con in iter_containers ()] ] __getattr__(name) Returns a dict of environ that given from specified container Examples: >>> from rezup import util_env >>> util_env . dot_main # the env also been applied onto os.environ { 'REZUP_CONTAINER' : '.main' , 'REZUP_USING_REMOTE' : '' } Source code in rezup/util_env.py def __getattr__ ( name ): \"\"\"Returns a dict of environ that given from specified container Example: >>> from rezup import util_env >>> util_env.dot_main # the env also been applied onto os.environ {'REZUP_CONTAINER': '.main', 'REZUP_USING_REMOTE': ''} \"\"\" if name [: 2 ] == name [ - 2 :] == \"__\" : raise AttributeError ( \"module %r has no attribute %r \" % ( __name__ , name )) if name == \"dot_main\" : con_name = \".main\" else : con_name = name revision = util . get_revision ( container = con_name ) env = revision . recipe_env () os . environ . update ( env ) return env","title":"rezup.util_env"},{"location":"rezup.util_env/#_1","text":"Container environ one-line injector Examples: from rezup.util_env import dot_main # the environ of container '.main' has been applied onto `os.environ` ... # import other stuff With this module, we could inject container environ at the top of script with import statement in one line, instead of something like this: from rezup.util import get_revision os . environ . update ( get_revision ( \".main\" ) . recipe_env ()) ... # import other stuff Which makes linter unhappy. However, Python 3.7+ Required The feature this module provides is based on PEP-562 , which requires Python 3.7+ to work.","title":""},{"location":"rezup.util_env/#__dir__","text":"Listing all container as valid importable attribute name Examples: >>> from rezup import util_env >>> dir ( util_env ) [ 'dev' , 'dot_main' ] Source code in rezup/util_env.py def __dir__ (): \"\"\"Listing all container as valid importable attribute name Example: >>> from rezup import util_env >>> dir(util_env) ['dev', 'dot_main'] \"\"\" return [ \"dot_main\" if name == \".main\" else name for name in [ con . name () for con in iter_containers ()] ]","title":"__dir__()"},{"location":"rezup.util_env/#__getattr__name","text":"Returns a dict of environ that given from specified container Examples: >>> from rezup import util_env >>> util_env . dot_main # the env also been applied onto os.environ { 'REZUP_CONTAINER' : '.main' , 'REZUP_USING_REMOTE' : '' } Source code in rezup/util_env.py def __getattr__ ( name ): \"\"\"Returns a dict of environ that given from specified container Example: >>> from rezup import util_env >>> util_env.dot_main # the env also been applied onto os.environ {'REZUP_CONTAINER': '.main', 'REZUP_USING_REMOTE': ''} \"\"\" if name [: 2 ] == name [ - 2 :] == \"__\" : raise AttributeError ( \"module %r has no attribute %r \" % ( __name__ , name )) if name == \"dot_main\" : con_name = \".main\" else : con_name = name revision = util . get_revision ( container = con_name ) env = revision . recipe_env () os . environ . update ( env ) return env","title":"__getattr__(name)"},{"location":"scripts/","text":"Programmatic usage from rezup import util # returns a revision from container revision = util . get_revision () # resolve package requests with Rez from container env = util . resolve_environ ( revision , [ \"pkg_a\" , \"pkg_b\" ]) Provisional recipes By default, all recipe files should be in user home directory and only there will be looked for. But in some cases, you may want to provide your own remotely . from rezup import util , ContainerRecipe with ContainerRecipe . provisional_recipes ( \"/to/other/recipes\" ): revision = util . get_revision () env = util . resolve_environ ( revision , [ \"pkg_a\" , \"pkg_b\" ])","title":"Scripts"},{"location":"scripts/#programmatic-usage","text":"from rezup import util # returns a revision from container revision = util . get_revision () # resolve package requests with Rez from container env = util . resolve_environ ( revision , [ \"pkg_a\" , \"pkg_b\" ]) Provisional recipes By default, all recipe files should be in user home directory and only there will be looked for. But in some cases, you may want to provide your own remotely . from rezup import util , ContainerRecipe with ContainerRecipe . provisional_recipes ( \"/to/other/recipes\" ): revision = util . get_revision () env = util . resolve_environ ( revision , [ \"pkg_a\" , \"pkg_b\" ])","title":"Programmatic usage"}]}